#define KEY_CLICKED 1
#define TRUE 1
#define FALSE 0
#define N_COLLIDE 30
#define LEFT 0
#define RIGHT 1
#define UP 2
#define DOWN 3
#define H_XCOR 1
#define L_XCOR 2
#define H_YCOR 3
#define L_YCOR 4
#define DIRECTION 5
#define ANIMATION 6
#define COUNTER 7
#define COUNTER2 8
#define COLLISION 1
#define COIN_COUNT 8
#define l_d 1 ; scalars for left\right\up\down
#define r_d 2
#define u_d 3
#define d_d 4
#define VECTOR 8
#define WIDTH 80
;==========================================================
;Blobby
;by: Christopher Jernigan
; jernchr@yahoo.com
;not complete
;==========================================================
  #include "ti83plus.inc"
#include "mirage.inc"
	.org $9d93    
	.db $BB,$6D    
	ret     
	.db 1    
	.db %00000000,%00000000  
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db %00000000,%00000000
	.db "Blobby, by: cjg0ne2",0

	ld hl,_enddata - data
	B_CALL(_DispHL)
	B_CALL(_Getkey)
	ld a,1
	out ($20),a
;----------------------------------------------------------
;MAIN LOOP
;---------------------------------------------------------
	Call DrawTileAlligned
	Call SetUpInterrupt
main:
	Call Getkeys
	Call CopyBuffer1toLCD
	Call Handle_Objects
	Call Handle_Jump
	Call Gravity
	Call Handle_Char_animation
	Call Handle_Invul
	;call fastCopy
	Call Draw_LCD
	Call delay
	jr main
;-----------------------------------------------------
;MAIN LOOP
;----------------------------------------------------
Handle_Char_animation:
	ld a,(velocity) \ or a \ jr nz,Faster
	ld a,(Animate_Tile)
	inc a \ and 63
	ld (Animate_Tile),a
	ret
Faster:
	cp 33 ; chk velocity for ultimate speed
	jr nc,Even_faster
	ld a,(Animate_Tile)
	inc a \ and 15
	ld (Animate_Tile),a
	ret
Even_faster:
	ld a,(Animate_Tile)	
	inc a \ and 7
	ld (Animate_Tile),a
	ret
DisplayChar:
	;ld a,(Jump_C)
	;or a \ jr nz,Draw_Jump
	ld de,BlockyL
	ld a,(Direction)
	dec a \ add a,a
	ld b,a
	Call Velocity_Handle
	ld a,c
	add a,b
	add a,a
	add a,a
	add a,a
	ld l,a
	ld h,0
	add hl,de
	ex de,hl
_drwc:
	ld hl,$9340
	Call DrawChar
	ret
Velocity_Handle:
	ld a,(velocity) \ or a \ jr z,Slowest
	cp 33
	jr nc,V_speed
	ld a,(Animate_Tile) 	
	cp 7 \ Call c, Set0 \ cp 7 \ Call nc,Set1
	ret
V_speed:
	ld a,(Animate_Tile) 	
	cp 3 \ Call c, Set0 \ cp 3 \ Call nc,Set1
	ret	
Slowest:
	ld a,(Animate_Tile) 
	cp 32 \ Call c, Set0 \ cp 32 \ Call nc,Set1
	ret
Set0:
	ld c,0
	ret
Set1:
	ld c,1
	ret
Draw_Jump:
	;ld de,Blob_Jump
	;jr _drwc
Animate_Tile:
	.db 0
Draw_LCD:

	xor a
	out ($20),a
	Call fastcopy
	ld a,1
	out ($20),a
	ret
DrawTileAlligned:
	ld de,Matrix+(WIDTH*6)
	ld hl,Buffer1
	ld b,8
_loopA:
	push bc
	ld b,12
_loopB:
	push bc
	push hl
	push de
	ld a,(de)
	Call PicR
	ld b,8
_copyTile:
	ld a,(de)
	ld (hl),a
	push de
	ld de,12
	add hl,de
	pop de
	inc de
	djnz _copyTile
	pop de
	inc de
	pop hl 
	inc hl
	pop bc
	djnz _loopB
	push de
	ld de,(12*8)-12
	add hl,de
	pop de
	push hl
	ld hl,WIDTH-12
	add hl,de
	ex de,hl
	pop hl
	pop bc
	djnz _loopA
	ret
	
Collision_On_Map:
	ld c,5
Handle_Collision:
;c = direction
	ld a,(Block_X)
	add a,a
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	ld a,(Block_X+1)
	dec a
	ld e,a
	ld d,0
	add hl,de
	;hl = xcor
	ld a,c
	cp LEFT
	Call z,Dec_hl
	cp RIGHT
	Call z,Inc_hl
	push hl
	ld a,(Block_Y)
	add a,a
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	ld a,(Block_Y+1)
	dec a
	ld e,a
	ld d,0
	add hl,de
	ld a,c
	cp UP
	Call z,Dec_hl
	cp DOWN
	Call z,Inc_hl
	ex de,hl
	pop hl
	xor a
	ld (Collision_C),a
	Call Collision_Obj
	ret
Dec_hl:
	dec hl
	ret
Inc_hl:
	inc hl
	ret
delay:
	ld a,(delay_c)
	cp 3 ; 1/110 of a second
	jr nc,Contix
	jp delay
Contix:
	xor a
	ld (delay_c),a
	ret

SetUpInterrupt:
	 di
	ld hl,$8B00
	ld (hl),$8A
	ld de,$8B01
	ld bc,256
	ldir
	ld hl,Interrupt_Start
	ld de,$8A8A
	ld bc,Interrupt_End-Interrupt_Start
	ldir
	ld a,%00001000		;Acknowledge and disable
	out (3),a
	ld a,%00001010		;Set 1st timer active
	out (3),a
	ld a,%00000110		;Slowest frequency, ~110hz
	out (4),a
	ld a,$8B
	ld i,a
	im 2
	ei
	ret
DispMem:
	ld hl, _enddata
	ld de,data
	or a
	sbc hl,de
	bcall(_disphl)
	bcall(_getkey)
	ret
handle_collision_ud:
	ld a,(Block_Y+1)
	cp 1
	jr nz,_end_collision

	ld a,(Block_Y)
	ld c,a
	ld a,(Block_X+1)
	ld h,a
	dec h
	ld a,(Block_X)
	Call CollisionChk
	ret
handle_collision_lr:
	ld a,(Block_X+1)
	cp 1
	jr nz,_end_collision

	ld a,(Block_Y)
	ld c,a
	ld a,(Block_Y+1)
	ld h,a
	dec h
	ld a,(Block_X)
	Call CollisionChk
	ret
_end_collision:
	xor a
	ret
	
CollisionChk:
;collision detection for the matrix tile map versus object X
; e = direction
;a = x tile
;c = y tile
;h = offset
;returns x>0 if collision is true
;returns 0 if collision is false
	ld ix,collision_ptr_x
	ld d,0
	add ix,de
	ld b,(ix)
	add a,b ;xcor
	ld l,a
	ld ix,collision_ptr_y
	add ix,de
	ld a,(ix)
	add a,c ; ycor
	ld c,a
	ld b,c
	push de
	ld ix,Matrix
	ld de,WIDTH
	or a
	jr z,_col_skip_add
_col_add:
	add ix,de
	djnz _col_add
_col_skip_add:
	ld a,l
	ld e,a
	ld d,0
	add ix,de
	ld a,(ix)
	Call PicR
	push hl
	ld hl,8
	add hl,de
	ld a,(hl)
	pop hl
	pop de
	or a   ; 1=solid, 0 = not solid
	ret nz  ; returns if the tile is solid
	ld a,h
	or a 
	ret z
	ld hl,collision_tbl
	add hl,de
	ld c,(hl)
	ld b,0  
	add ix,bc
	ld a,3
	sub e
	ld e,a
	ld hl,collision_tbl
	add hl,de
	ld c,(hl)
	ld a,c \ or a \ Call nz,Force_WIDTH
	;sla c \ sla c \ sla c \ ld a,c \ sla c \ ld b,c  \ sla c \ add a,c \ add a,b     ;either   1 * WIDTH or  0 * WIDTH
	ld b,0
	ld c,a
	add ix,bc
	ld a,(ix)
	Call PicR
	ld hl,8
	add hl,de
	ld a,(hl) ; 1= solid, 0 = not solid
	or a
	ret z
	ld a,1
	ret
Force_WIDTH:
	ld a,WIDTH
	ret
	
Handle_Invul:
	ld a,(Invul_C)
	or a
	jr z,drwchar
	push af
	and 1
	cp 1
	jr z,_invul
		;1
	Call DisplayChar
_invul:
	pop af
	inc a
	and 127
	ld (Invul_C),a
	ret
drwchar:
	Call DisplayChar
	ret
		
	

CopyBuffer1toLCD:
	ld hl,Buffer1
	ld de,$9340
	ld bc,768
CopyBuffer:
	ldi \ ldi \ ldi \ ldi
	ldi \ ldi \ ldi \ ldi
	ldi \ ldi \ ldi \ ldi
	ldi \ ldi \ ldi \ ldi
	jp pe,CopyBuffer
	ret
Buffer_Counter:

Getkeys:
	ld a,$FF
	out (1),a
	nop
	ld a,$BF
	out (1),a
	nop
	nop
	in a,(1)
	cp $FE
	jp z,_End
	ld a,$FF
	out (1),a
	nop
	ld a,$FE
	out (1),a
	nop
	nop
	in a,(1)
	cp $FD
	Call z,Left
	ld a,$FF
	nop
	out (1),a
	ld a,$FE
	out (1),a
	nop
	nop
	in a,(1)
	cp $FB
	Call z,Right
	ld a,$FF
	nop
	out (1),a
	ld a,$BF
	out (1),a
	nop
	nop
	in a,(1)
	cp $Df
	Call z,Jump
	
	ld a,$FF
	nop
	out (1),a
	ld a,$FE
	out (1),a
	nop
	nop
	in a,(1)
	cp $F7
	Call z,Up
	ld a,$FF
	nop
	out (1),a
	ld a,$FE
	out (1),a
	nop
	nop
	in a,(1)
	cp $FE
	Call z,Down
	ld a,(Dir_C) \ or a \ Call z,Decrease_Velocity \ xor a \ ld (dir_C),a
	ret
Decrease_Velocity:
	ld a,(Dir_C)
	;; 2 = right, 1 = left
	or a \ jr z,Decr_vel  ; if direction is 0 than object is at a standstill
	push af
	cp 1 \ Call z,Left
	pop af \ cp 2
	Call Right
Decr_vel:
	ld a,(Velocity)	
	cp 0 \ ret z \ cp 1 \ jr z,dec
	dec a 
dec:
	dec a
	ld (velocity),a
	ret
_End:
	;ld a,(Coordstruct)
	;ld h,0
	;ld l,a
	;B_CALL(_DispHL)
	;B_CALL(_NewLine)
	;ld a,(Coordstruct+1)
	;ld h,0
	;ld l,a
	;B_CALL(_DispHL)
	;di 
	;im 1
	;B_CALL(_NewLINE)
	di
	im 1
	ei
	ld a, (coins)
	ld l,a
	ld h,0
	B_CALL(_disphl)
	B_CALL(_newline)
	
	pop hl ; address
	
	ret
GameOver:
	.db "Gameover!",0
Jump:
	ld a,(Jump_C)
	cp 0
	ret nz
	ld c,DOWN
	Call Handle_Collision
	ld a,(Collision_C)
	or a
	jr nz,Skip_Tile_Jump
	ld e,DOWN
	Call handle_collision_ud
	or a
	ret z
Skip_Tile_Jump:
	ld a,1
	ld (Jump_C),a
	ret
Handle_Jump:
	ld a,(Jump_C)
	or a
	ret z
	Call Up
	ld a,b
	cp 1
	Call nz,Force_End_Jump
	ld a,(Jump_C)
	inc a
	cp 26
	jr z,Jump_reset
	ld (Jump_C),a
	ret
Jump_reset:
	xor a
	ld (Jump_C),a
	ret
Force_End_Jump:
	ld a,25
	ld (Jump_C),a
	ret
Gravity:
	;ld a,(Grav_C)
	;inc a \ and 1 \ ld (Grav_C),a
	;or a
	;ret z
	ld a,(Jump_C)
	or a
	ret nz
	Call Down
	ret

Up:
	ld c,UP
	Call Handle_Collision
	ld a,(Collision_C)
	ld b,0
	cp COLLISION
	ret z
	ld e,UP
	Call handle_collision_ud
	ld b,0
	or a
	ret nz
Up_Skip:
	Call MoveUp
	ld b,1
	ld a,(Block_Y)
	cp 3
	ret c
	cp 13  
	ret nc
	ld a,(Up_Offset)
	dec a
	Call z,Resetm_Up
	ld (Up_Offset),a	
	ld a,(Down_Offset)
	dec a
	Call z,Resetm_Down
	ld (Down_Offset),a	
	Call UpScroll
	ld b,1
	ret
Down:
	ld c,DOWN
	Call Handle_Collision
	ld a,(Collision_C)
	cp COLLISION
	ret z
	ld e,DOWN
	Call handle_collision_ud
	or a
	ret nz
	Call MoveDown
	ld a,(Block_YY)
	cp 4
	ret c
	cp 14
	ret nc
	ld a,(Up_Offset)
	inc a
	cp 9
	Call z,Resetp_Up
	ld (Up_Offset),a
	ld a,(Down_Offset)
	inc a
	cp 9
	Call z,Resetp_Down
	ld (Down_Offset),a
	Call DownScroll
	ret
IncA:
	inc a
	ret
Right:
	ld a,(velocity)
	ld b,a
	ld a,(acceleration)
	add a,b
	cp 35 \ jr z,_rrl
	ld (velocity),a
_rrl:
	srl a \ srl a \ srl a \ srl a
	or a \ Call z,IncA
	ld b,a
_rloop:
	push bc
	Call l_right
	pop bc
	djnz _rloop
	ret
	
l_right:
	ld a,2
	ld (Direction),a
	ld (Dir_C),a
	ld c,RIGHT
	Call Handle_Collision
	ld a,(Collision_C)
	cp COLLISION
	ret z
	ld e,RIGHT
	Call handle_collision_lr
	or a
	ret nz
right_Skip:
	Call MoveRight
	ld a,(Block_XX)
	cp 7             
	ret c
	cp WIDTH-6+1                
	ret nc
	ld a,(Right_Offset)
	inc a
	cp 9
	Call z,Resetp_Right
	ld (Right_Offset),a
	ld a,(Left_Offset)
	inc a
	cp 9
	Call z,Resetp_Left
	ld (Left_Offset),a
	Call RightScroll
	ret
Left:
	ld a,(velocity)
	ld b,a
	ld a,(acceleration)
	add a,b
	cp 35 \ jr z,llr
	ld (velocity),a
llr:
	srl a \ srl a \ srl a \ srl a
	or a \ Call z,IncA
	ld b,a
_lloop:
	push bc
	Call l_left
	pop bc
	djnz _lloop
	ret
	
l_left:	
	ld a,1
	ld (Direction),a
	ld (Dir_C),a
	ld c,LEFT
	Call Handle_Collision
	ld a,(Collision_C)
	cp COLLISION
	ret z
	ld e,LEFT
	Call handle_collision_lr
	or a
	ret nz
Left_Skip:
	Call MoveLeft
	ld a,(Block_X)
	cp 6             ;always 6
	ret c
	cp WIDTH-6                     ; width - 6      , 56 -6 = 27
	ret nc
	ld a,(Left_Offset)
	dec a
	Call z,Resetm_Left
	ld (Left_Offset),a
	ld a,(Right_Offset)
	dec a
	Call z,Resetm_Right
	ld (Right_Offset),a
	Call LeftScroll
	ret
Resetp_Right:
	ld a,(Right_Max)
	inc a
	ld (Right_Max),a
	Call Check_ObjR
	ld a,1
	ret
Resetp_Up:
	ld a,(Up_Max)
	inc a
	ld (Up_Max),a
	ld a,1
	ret
Resetp_Down:
	ld a,(Down_Max)
	inc a
	ld (Down_Max),a
	Call Check_ObjD
	ld a,1
	ret
Resetp_Left:
	ld a,(Left_Max)
	inc a
	ld (Left_Max),a
	ld a,1
	ret
Resetm_Right:
	ld a,(Right_Max)
	dec a
	ld (Right_Max),a
	ld a,8
	ret	
Resetm_Left:
	ld a,(Left_Max)
	dec a
	ld (Left_Max),a
	Call Check_ObjL
	ld a,8
	ret
Resetm_Up:
	ld a,(Up_Max)
	dec a
	ld (Up_Max),a
	Call Check_ObjU
	ld a,8
	ret
Resetm_Down:
	ld a,(Down_Max)
	dec a
	ld (Down_Max),a
	ld a,8
	ret	
;-----------------------------------------
;End of Code
;-----------------------------------------
;-----------------------------------------
;Scrolling Routines
;-----------------------------------------
;------------------------------------------
;UP AND DOWN
;------------------------------------------
UpScroll:
	ld de,Buffer1 + ( 63 * 12 ) + 11 ;first row
	ld hl,Buffer1+ ( 62 * 12) + 11; next row 
	; our goal is to copy  row 2 to row 1, row 3 to row 2, row 4 to row 3
	ld b,63 ; 64 rows
ScrollUp:
	push bc
	ldd \ ldd \ ldd
	ldd \ ldd \ ldd  ; 12 * 63
	ldd \ ldd \ ldd
	ldd \ ldd \ ldd
	pop bc
	djnz ScrollUp
	ld hl,Matrix	
	ld a,(Up_Max)
	or a
	jr z,_noffset2
	ld b,a
	ld de,WIDTH
_addup2:
	add hl,de
	djnz _addup2
_noffset2:
	ld a,(Left_Max)
	ld e,a
	ld d,0
	add hl,de

	ld a,(Up_Offset)
	dec a
	ld c,a
	ld b,12
	ex de,hl
	ld hl,Buffer1 ; top row
_Up:
	push de
	ld a,(de)
	Call PicR
	push hl
	ld l,c
	ld h,0  ; offset
	add hl,de  ; add offset
	ld a,(hl)
	pop hl
	ld (hl),a   
	pop de
	inc de
	inc hl
	djnz _Up
	ld a,(Left_Offset)
	dec a 
	or a
	jr z,Scroll_No_Offset
	ld b,a
	ld a,(de)
	call PicR
	ld l,c
	ld h,0
	add hl,de
	ex de,hl

Scroll_Up_Left:
	ld hl,Buffer1+11
	or a
	sla (hl)
	dec hl \ rl (hl) \ dec hl \ rl (hl)  
	dec hl \ rl (hl) \ dec hl \ rl (hl)  
	dec hl \ rl (hl) \ dec hl \ rl (hl)  ; 11 times
	dec hl \ rl (hl) \ dec hl \ rl (hl)  
	dec hl \ rl (hl) \ dec hl \ rl (hl)
	dec hl \ rl (hl) 
	djnz Scroll_Up_Left
	ld a,(Left_Offset)
	dec a
	ld b,a
	ld a,(de)
	ld c,a
	ld hl,Buffer1+11
	xor a
Fill_Up_Rotate:
	sla c
	rla
	djnz Fill_Up_Rotate
	or (hl)
	ld (hl),a
	
Scroll_No_Offset:
	ret
	
DownScroll:
	ld de,Buffer1 ;first row
	ld hl,Buffer1+12 ; next row 
	; our goal is to copy  row 2 to row 1, row 3 to row 2, row 4 to row 3
	ld b,63 ; 64 rows
ScrollDown:
	push bc
	ldi \ ldi \ ldi
	ldi \ ldi \ ldi  ; 12 * 64 
	ldi \ ldi \ ldi
	ldi \ ldi \ ldi
	pop bc
	djnz ScrollDown
	ld hl,Matrix
	ld a,(Down_Max)
	or a
	jr z,_noffset
	ld b,a
	ld de,WIDTH
_addup:
	add hl,de
	djnz _addup
_noffset:
	ld a,(Left_Max)
	ld e,a
	ld d,0
	add hl,de
	
	ld a,(Down_Offset)
	dec a
	ld c,a
	ld b,12
	ex de,hl
	ld hl,Buffer1+ ( 63 * 12 ) ; bottom row
_Down:
	push de
	ld a,(de)
	Call PicR
	push hl
	ld l,c
	ld h,0  ; offset
	add hl,de  ; add offset
	ld a,(hl)
	pop hl
	ld (hl),a   ; looks ironic without the 'pop hl'
	pop de
	inc de
	inc hl
	djnz _Down
	
	ld a,(Left_Offset)
	dec a 
	or a
	jr z,Scroll_No_Offset2
	ld b,a
	ld a,(de)
	call PicR
	ld l,c
	ld h,0
	add hl,de
	ex de,hl
Scroll_Down_Left:
	ld hl,Buffer1+11 + ( 63 * 12)
	or a
	sla (hl)
	dec hl \ rl (hl) \ dec hl \ rl (hl)  
	dec hl \ rl (hl) \ dec hl \ rl (hl)  
	dec hl \ rl (hl) \ dec hl \ rl (hl)  ; 11 times
	dec hl \ rl (hl) \ dec hl \ rl (hl)  
	dec hl \ rl (hl) \ dec hl \ rl (hl)
	dec hl \ rl (hl) 
	djnz Scroll_Down_Left
	ld a,(Left_Offset)
	dec a
	ld b,a
	ld a,(de)
	ld c,a
	ld hl,Buffer1+11 + ( 63 * 12)
	xor a
Fill_Down_Rotate2:
	sla c
	rla
	djnz Fill_Down_Rotate2
	or (hl)
	ld (hl),a
Scroll_No_Offset2:
	ret	
	ret
;------------------------------------
;Left\ Right
;------------------------------------
Rightscroll:
	ld hl,Buffer1 + 11
	ld de,23
	ld b,64
;-------------------
_RotateR:
	or a
	sla (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	dec hl
	rl (hl)
	add hl,de
	djnz _RotateR
;------------------------------------------ 
	ld a,(Right_Max)
	ld d,0
	ld e,a
	ld hl,Matrix	
	add hl,de
	ld de,WIDTH
	ld a,(Up_Max)
	or a
	jr z,No_Offset
	ld b,a
_addoffset:
	add hl,de
	djnz _addoffset
No_Offset:	
	; this code draws the top offset IF IT EXISTS, however, no offset, it will skip 
	ld a,(Up_Offset)
	ld b,a
	ld a,8  ; 
	sub b  ; top offset if any
	cp 7                     ; no offset is 1 so 8-1 = 7
	jr nz,TopOffset
NoTopOffset:
	ld b,8
	ex de,hl
	ld hl,Buffer1 + 11
	jr _R
TopOffset:
	inc a
	ld b,a  ; sets b
	ld a,(hl) ; normally de, matrix
	Call PicR
	push hl
	ld a,(Up_Offset)
	ld h,0
	ld l,a
	dec l
	add hl,de  ; image offset
	ex de,hl ; iamge now in de
	ld hl,Buffer1+11	; LCD buffer
	Call _DrawR
	pop de
	push hl
	ld hl,WIDTH
	add hl,de ; we drew a tile, so now we must move down a row, and 56 = row length
	ex de,hl
	pop hl
	ld b,7 ; if the offset was drawn at the top this concludes that there are 9 tiles to draw, 2 with offsets, and 7 with no offset
	; if the top was skipped, that means a - b = 0  and a = 8, so that means 8-8 = 0....meaning b = 8, so it works out
	; 8 is what B is normally
_R:
	push bc   ;push
	ld a,(de)
	push de   ; push
	Call PicR
	ld b,8
	Call _DrawR
	pop de ;pop
	push hl ;push
	ld hl,WIDTH
	add hl,de
	ex de,hl
	pop hl ;pop
	pop bc  ;pop
	djnz _R
	; draw bottom if offset
	ld a,(Up_Offset)
	dec a
	or a
	ret z
	ld b,a
	ld a,(de)
	Call PicR
	Call _DrawR
	ret
_DrawR:
;arguments
; b = # of rows to draw
; de = picture + offset
;hl = LCD buffer
	ld a,(Right_Offset)
	push bc	;push
	ld b,a
	ld a,(de)
	ld c,a
	xor a
	or a
_ShiftR:
	sla c
	djnz _ShiftR
	rla
	or (hl)
	ld (hl),a
	ld bc,12
	add hl,bc
	inc de
	pop bc ; pop 
	djnz _DrawR
	ret
LeftScroll:	
	ld hl,Buffer1
	ld b,64
;-------------------Note: this is a general routine, I didn't write
_RotateL:
	or a
	srl (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	rr (hl)
	inc hl
	djnz _RotateL
;-----------------------------
	ld a,(Left_Max)
	ld d,0
	ld e,a
	ld hl,Matrix	
	add hl,de
	ld de,WIDTH
	ld a,(Up_Max)
	or a
	jr z,No_Offset2
	ld b,a
_addoffset2:
	add hl,de
	djnz _addoffset2
No_Offset2:	

	; this code draws the top offset IF IT EXISTS, however, no offset, it will skip 
	ld a,(Up_Offset)
	ld b,a
	ld a,8  ; 
	sub b  ; top offset if any
	cp 7                     ; no offset is 1 so 8-1 = 7
	jr nz,TopOffset2
NoTopOffset2:
	ld b,8
	ex de,hl
	ld hl,Buffer1
	jr _L
TopOffset2:
	inc a
	ld b,a  ; sets b
	
	ld a,(hl) ; normally de, matrix
	Call PicR
	push hl
	ld a,(Up_Offset)
	ld h,0
	ld l,a
	dec l
	add hl,de  ; image offset
	ex de,hl ; iamge now in de
	ld hl,Buffer1	; LCD buffer
	Call _DrawL
	pop de

	push hl
	ld hl,WIDTH
	add hl,de ; we drew a tile, so now we must move down a row, and 56 = row length
	ex de,hl
	pop hl
	ld b,7 ; if the offset was drawn at the top this concludes that there are 9 tiles to draw, 2 with offsets, and 7 with no offset
	; if the top was skipped, that means a - b = 0  and a = 8, so that means 8-8 = 0....meaning b = 8, so it works out
	; 8 is what B is normally
_L:
	push bc   ;push
	ld a,(de)
	push de   ; push
	Call PicR
	ld b,8
	Call _DrawL
	pop de ;pop
	push hl ;push
	ld hl,WIDTH
	add hl,de
	ex de,hl
	pop hl ;pop
	pop bc  ;pop
	djnz _L
	; draw bottom if offset
	ld a,(Up_Offset)
	dec a
	or a
	ret z
	ld b,a
	ld a,(de)
	Call PicR
	Call _DrawL
	ret
_DrawL:
	ld a,(Left_Offset)
	push bc	;push
	ld b,a
	ld a,(de)
	ld c,a
	xor a
_ShiftL:
	sla c
	djnz _ShiftL
	rra
	or (hl)
	ld (hl),a
	ld bc,12
	add hl,bc
	inc de
	pop bc ; pop 
	djnz _DrawL
	ret	
;-----------------------------------------
Subroutines:
;-----------------------------------------
y_Collide_add:
	srl b \ rr c \ or a
	srl b \ rr c \ or a
	srl b \ rr c \ or a ; bc by 8	
	;c = bc / 8
	ld hl,Matrix
	xor a
	cp c
	jr z,_ynoadd0
	ld b,c
	ld de,WIDTH
_ycollide:
	add hl,de
	djnz _ycollide
_ynoadd0:
	ret
x_Collide_add:
	srl d \ rr e \ or a
	srl d \ rr e \ or a  ; divide by 8
	srl d \ rr e \ or a
	; e now has the de / 8
	ld d,0
	add hl,de ; xcor added
	ret


PicR:
;bitmap images \ static unmoving objects :o
    push hl
	push af
	add a,a   ; a*2 (limits SpriteNumber to 128) 
	ld h,0 
	ld l,a 
	ld de,SpriteAddressLUT
	add hl,de
	ld a,(hl)
	inc hl
	ld d,(hl)
	ld e,a
	pop af
	pop hl
    ret
	
; used for static objects that move or animate
PicRx:
    push hl
	push af
	add a,a   ; a*2 (limits SpriteNumber to 128) 
	ld h,0 
	ld l,a 
	ld de,SpriteAddressLUTx
	add hl,de
	ld a,(hl)
	inc hl
	ld d,(hl)
	ld e,a
	pop af
	pop hl
    ret

fCopy:
	di
	xor a
	out ($20),a
 	ld a,$80
 	out ($10),a
 	ld hl,$9340-12-(-(12*64)+1)
	ld a,$20
	ld c,a
	inc hl
 	dec hl
fCopyAgain:
 	ld b,64
 	inc c
	ld de,-(12*64)+1
 	out ($10),a
	add hl,de
 	ld de,10
fCopyLoop:
 	add hl,de
 	inc hl
 	inc hl
 	inc de
	ld a,(hl)
	out ($11),a
	dec de
	djnz fCopyLoop
 	ld a,c
	cp $2B+1
 	jr nz,fCopyAgain

	ld a,01
	out ($20),a
	ei
	ret	

PutSpriteXOR:
    ; A = x coordinate
; L = y coordinate
; B = number of rows
; IX = address of sprite
    LD     H, 0
    LD     D, H
    LD     E, L
    ADD    HL, HL
    ADD    HL, DE
    ADD    HL, HL
    ADD    HL, HL
    LD     E, A
    SRL    E
    SRL    E
    SRL    E
    ADD    HL, DE
    LD     DE, $9340
    ADD    HL, DE
    AND    7
    JR     Z, Alignedx
    LD     C, A
    LD     DE, 12
RowLoopx:
    PUSH   BC
    LD     B, C
    .db $DD, $4E, $00
    XOR    A
ShiftLoopx:
    SRL    C
    RRA
    djnz ShiftLoopx
    INC    HL
    XOR    (HL)
    LD     (HL), A
    DEC    HL
    LD     A, C
    XOR    (HL)
    LD     (HL), A
    ADD    HL, DE
    INC    IX
    POP    BC
    djnz RowLoopx
    jr Endx
Alignedx:
    LD     DE, 12
PutLoopx:
    .db $DD, $7E, $00
    XOR    (HL)
    LD     (HL), A
    INC    IX
    ADD    HL, DE
    DJNZ   PutLoopx
Endx:	
	ret
	
	
	
ClipSprXOR:
; D = xpos
; E = ypos
; B = height
; IX = image address
; Start by doing vertical clipping
    LD     A, %11111111         ; Reset clipping mask
    LD     (clip_mask), A
    LD     A, E                 ; If ypos is negative
    OR     A                    ; try clipping the top
    JP     M, ClipTop           ;
 
    SUB    64                   ; If ypos is >= 64
    RET    NC                   ; sprite is off-screen

    NEG                         ; If (64 - ypos) > height
    CP     B                    ; don't need to clip
    JR     NC, VertClipDone     ; 

    LD     B, A                 ; Do bottom clipping by
    JR     VertClipDone         ; setting height to (64 - ypos)

ClipTop:
    LD     A, B                 ; If ypos <= -height
    NEG                         ; sprite is off-screen
    SUB    E                    ;
    RET    NC                   ;

    PUSH   AF
    ADD    A, B                 ; Get the number of clipped rows
    LD     E, 0                 ; Set ypos to 0 (top of screen)
    LD     B, E                 ; Advance image data pointer
    LD     C, A                 ;
    ADD    IX, BC               ;
    POP    AF
    NEG                         ; Get the number of visible rows
    LD     B, A                 ; and set as height

	
	
VertClipDone:
; Now we're doing horizontal clipping
    LD     C, 0                 ; Reset correction factor
    LD     A, D

    CP     -7                   ; If 0 > xpos >= -7
    JR     NC, ClipLeft         ; clip the left side

    CP     96                   ; If xpos >= 96
    RET    NC                   ; sprite is off-screen

    CP     89                   ; If 0 <= xpos < 89
    JR     C, HorizClipDone     ; don't need to clip

ClipRight:
    AND    7                    ; Determine the clipping mask
    LD     C, A
    LD     A, %11111111
FindRightMask:
    ADD    A, A
    DEC    C
    JR     NZ, FindRightMask
    LD     (clip_mask), A
    LD     A, D
    JR     HorizClipDone

ClipLeft:
    AND    7                    ; Determine the clipping mask
    LD     C, A
    LD     A, %11111111
FindLeftMask:
    ADD    A, A
    DEC    C
    JR     NZ, FindLeftMask
    CPL
    LD     (clip_mask), A
    LD     A, D
    ADD    A, 96                ; Set xpos so sprite will "spill over"
    LD     C, 12   

	; Set correcti
HorizClipDone:
; A = xpos
; E = ypos
; B = height
; IX = image address

; Now we can finally display the sprite.
    LD     H, 0
    LD     D, H
    LD     L, E
    ADD    HL, HL
    ADD    HL, DE
    ADD    HL, HL
    ADD    HL, HL

    LD     E, A
    SRL    E
    SRL    E
    SRL    E
    ADD    HL, DE

    LD     DE, $9340
    ADD    HL, DE

    LD     D, 0                 ; Correct graph buffer address
    LD     E, C                 ; if clipping the left side
    SBC    HL, DE               ;

    AND    7
    JR     Z, _Aligned

    LD     C, A
    LD     DE, 11

_RowLoop:
    PUSH   BC
    LD     B, C
    LD     A, (clip_mask)       ; Mask out the part of the sprite
    AND    (IX)                 ; to be horizontally clipped
    LD     C, 0

_ShiftLoop:
    SRL    A
    RR     C
    DJNZ   _ShiftLoop

    XOR    (HL)
    LD     (HL), A

    INC    HL
    LD     A, C
    XOR    (HL)
    LD     (HL), A

    ADD    HL, DE
    INC    IX
    POP    BC
    DJNZ   _RowLoop
	ld d,200
    RET

_Aligned:
    LD     DE, 12

_PutLoop:
    LD     A, (IX)
    XOR    (HL)
    LD     (HL), A
    INC    IX
    ADD    HL, DE
    DJNZ   _PutLoop
	ld d,200
    RET

clip_mask:      .DB     0
;-----------------------------------------
;Static Objects handling
;-----------------------------------------
; READS MATRIX AND FINDS SPECIFIC SQUARES THAT TRIP MINE STATIC\INTERACTIVE OBJECTS

; OBJECT IS CREATED AND MANTAINED
;-----------------------------------------
;Object routines
;-----------------------------------------
CreateNewObj:
; very weird function
	sla l
	add hl,hl
	add hl,hl
	push bc
	push bc
	push hl
	push af

	push bc
	ld b,40
	ld hl,Objstruct
	ld de,9
_find_loop:
	ld a,(hl)
	cp 0
	jr z,EmptyObjFound
	add hl,de
	djnz _find_loop
	pop af \ pop af \ pop af \ pop af \ pop bc
	pop de ;address
	pop hl ; teh place that needs to be brought back
	ld a,(saved) \ ld (hl),a \ push hl \ push de
	ret
	
EmptyObjFound:
	ld a,40
	sub b
	pop bc
	push hl
	pop ix
	
	
	ld c,b
	;ld a,(_ptr)
	sla a
	ld d,0
	ld e,a
	ld hl,CoordStruct
	add hl,de
	pop af
	ld (hl),a
	inc hl
	;ld a,8
	ld a,(Up_Max)
	ld b,a
	ld a,(Down_Max)
	sub b
	inc a
	ld b,a
	ld a,(Up_Max)
	add a,b
	ld b,a
	ld a,(Temp3) ;down_max
	add a,b
	sub c
	ld (hl),a
	;pop hl
	;push hl
	;pop de
	;>ex de,hl
	;ld b,a
	;add a,a
	;add a,a
	;add a,b ; a * 5
	;ld e,a
	;ld d,0
	push ix
	pop hl
	push af
	ld a,(Saved)
	ld (hl),a
	pop af
	inc hl
	pop de
	ld (hl),d
	inc hl
	ld (hl),e
	inc hl

	ld a,(Up_Max)
	ld b,a
	ld a,(Down_Max)
	sub b ; 8 or 9
	inc a
	ld b,a
	ld a,(Up_Max)
	add a,b
	ld b,a
	ld a,(Temp3)
	add a,b
	pop bc
	sub b
	add a,a
	
	ld e,a
	ld d,0
	ex de,hl
	add hl,hl
	add hl,hl
	ex de,hl
	
	;add a,a	
	;add a,a
	ld (hl),d
	inc hl
	ld (hl),e
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	pop bc
	ret
	;------------------------
	;----------------------
Handle_Objects:
;spankin new
	ld hl,ObjStruct
	ld b,40   ; 32 objects
_Objs:
	xor a
	ld (LCD_Counter),a
	push hl
	ld a,(hl)  ; status { 0 = not defined, 1 - x = picture and task
	or a
	jr z,NextObj
	;/*
	push bc
	;*/
	;inc hl
	;ld d,(hl)
	;inc hl
	;ld e,(hl)  ; de = x cor 
	;inc hl
	;ld b,(hl) ; ycor
	;inc hl
	;ld c,(hl)
	; the tasks
	; a should be saved AND ONLY MODIFIED to change the picture
	; b must be saved ( cannot be modified)
	; c = y cor............ if modified load into HL ........ however, if you want the effect to take place, this value must also be changed when UpdatePic is called
	; same with de, xcor
	
	; so if you subtract one from de, you load this into hl and keep it as:
	
	;dec de
	;dec hl          // go down the structure
	;ld (hl),e
	;dec hl
	;ld (hl),d
	;jp UpdatePic      // DE is still one less... not restored back to the original value...
	
		;hl = low byte of ycor
	;ix = id
	;ix+1 = high byte of ycor
	;ix+2 = low byte of xcor
	;ix+3 = high byte of ycor
	;ix +4= low byte of ycor
	
	push hl
	pop ix
	ld hl,UpdatePic
	push hl
	ld hl,Task_Table
	ld e,a
	ld d,0
	add hl,de
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	push de
	ret
UpdatePic:
	; this routine requires 'a' to draw the image....
	; you can be smart and modify a to draw a new pic
	push de
	call picrX
	push de
	pop ix
	pop de
	; de = pic
	ld a,(Left_Max)
	sla a
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	push de
	ld a,(Left_Offset)
	dec a
	ld e,a
	ld d,0
	add hl,de
	pop de
	ex de,hl
	;Call Handle_LCD
	or a
	sbc hl,de	
	ld d,l
	;ld e,c
	ld a,(Up_Max)   ; ld e,c 
	add a,a
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	ld a,(Up_Offset)
	dec a
	push de
	ld e,a
	ld d,0
	add hl,de
	ld e,c
	ld d,b
	ex de,hl
	;Call Handle_LCD
	or a
	sbc hl,de
	pop de
	ld e,l	
	ld b,8
	; D = xpos
	; E = ypos
	; B = height
	; IX = image address
	; Start by doing vertical clipping
	;ld a,(LCD_Counter)
	;cp 1
	;jr z,NextSprite
	Call ClipSprXOR
	ld a,d
	cp 200
	Call nz,DeleteObj
NextSprite:
	pop bc
NextObj:
	pop hl
	ld de,9
	add hl,de
	djnz _Objs
	ret
DeleteObj:
	pop de ; address
	pop bc ; object number
	pop hl ; object picutre pointer

	push hl
	push bc
	push de	
	
	ld e,(hl)
	ld d,0
	ld c,(hl)
	push hl
	ld hl,Delete_Table
	add hl,de	
	ld a,(hl)
	pop hl
	or a
	ret z
	push hl
	ld (hl),0
	ld hl,Restore_Table
	add hl,de
	ld a,(hl)
	pop hl
	or a
	ret z
	ld a,40
	sub b
	sla a
	ld d,0
	ld e,a
	ld hl,CoordStruct
	add hl,de
	ld a,(hl)
	inc hl
	ld b,(hl)
	ld hl,Matrix_L2
	ld e,a
	ld d,0
	add hl,de
	ld de,WIDTH
	xor a
	cp b
	jr z,DontAddLoop
AddLoop:
	add hl,de
	djnz AddLoop
DontAddLoop:
	ld (hl),c
	ret	
Handle_LCD:
	;hl =  obj coor
	; de = screen cor
	or a
	sbc hl,de
	add hl,de ; cp hl,de
	jr c,HL_L_DE
	ret z
HL_G_DE:
	push hl
	push de
	or a
	sbc hl,de ; find the difference
	ld de,100
	or a 
	sbc hl,de
	add hl,de ; cp hl,de
	jr nc,PicFailed    ;hl >de
	pop de
	pop hl
	xor a
	ret
Hl_L_DE:
	push hl
	push de
	ex de,hl
	or a
	sbc hl,de ; find the difference
	ld de,10
	or a 
	sbc hl,de
	add hl,de ; cp hl,de
	jr nc,PicFailed    ;hl >de
	pop de
	pop hl
	xor a
	ret
PicFailed:
	pop de
	pop hl
	ld a,1
	ld (LCD_counter),a
	ret
LCD_counter:
.db 0
	

Task1:
	Call Restore_Values
	ret
Task2:
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr z,Task2_end
	Call Gravity_Handle
Task2_end:
	Call Restore_Values
	ret
Task3:
	ld a,(ix+COUNTER)
	inc a \ and 15 \ ld (ix+COUNTER),a
	or a
	jr nz,Task3_end 
	ld hl,Coin_Animation
	Call Handle_Animation
Task3_end:
	Call Restore_Values
	ret
Task4:  ; task 3 and 4 are directly correlated
	Call Restore_Values
	ret
Task5: ;goomba
	ld a,(ix+COUNTER)
	inc a \ and 1 \ ld (ix+COUNTER),a
	or a
	jr z,Task5_Restore_end
	Call Gravity_Handle
	ld hl,Goomba_Animation
	Call Handle_Animation
	Call Left_Right_Movement
Task5_Restore_end:
	Call Restore_Values
	ret
Task6:
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr nz,Task6_end 
	ld hl,Question_Animation
	Call Handle_Animation
Task6_end:
	Call Restore_Values
	ret
Task7:
	ld a,(ix+COUNTER)
	inc a \ and 1 \ ld (ix+COUNTER),a
	or a
	jr z,Task7_End
	Call Gravity_Handle
Task7_End:
	Call Restore_Values
	ret
Task8:	;beetle
	ld a,(ix+COUNTER)
	inc a \ and 1 \ ld (ix+COUNTER),a
	or a
	jr z,Task8_Restore_end
	ld a,(ix+DIRECTION)
	ld b,a
	add a,a
	add a,b
	ld e,a
	ld d,0
	ld hl,BeetleL_Animation
	add hl,de
	Call Handle_Animation
	Call Left_Right_movement
Task8_Restore_end:
	Call Restore_Values
	ret	
Task9:
	Call Restore_Values
	ret
Task10:
	ld a,(ix+COUNTER)
	inc a \ and 15 \ ld (ix+COUNTER),a
	or a
	jr nz,Task10_end
	ld hl,grass_animation
	Call Handle_Animation
Task10_end:
	Call Restore_Values
	ret
Task11:
	ld a,(ix+VECTOR)
	cp 1
	jr z, Task11_throw
	cp 2
	jr z,Task11_Hit
	Call Hold_Object
	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	cp $BF
	jr nz,Task11_End
	ld (ix+VECTOR),1
	ld a,(direction)
	ld (ix+DIRECTION),a
	ld (ix+ANIMATION),0 ; not being used for animation, but more for physics counter 0 -23
Task11_End:
	Call Restore_Values
	ret
Task11_throw:
	;ld a,(ix+COUNTER)
	;inc a \ and 1 \ ld (ix+COUNTER),a
	;or a
	;jr nz,_Task11End
	Call Parabolic_toss
	ld b,40
	ld hl,objstruct
_Task11_Collision:
	push hl
	ld a,(hl)
	cp 9
	jr z,_Task11_C
	cp 38
	jr z,_Task11_C
	jr _Task11_next
_Task11_C:
	Call Handle_Object_Collision
_Task11_next:
	pop hl
	ld de,9
	add hl,de
	djnz _Task11_Collision
_Task11End:
	Call Restore_Values
	ret
Task11_Hit:
	ld a,(ix)
	cp 34 ; turnip
	Call z,Task11_Turnip
	cp 27 ; turnip
	Call z,Task11_Grass
	ld (ix+COUNTER2),0
	ld (ix+COUNTER),0
	jr _Task11End
Task11_Turnip:
	ld (ix),35
	ret
Task11_Grass:
	ld (ix),31
	ret
	
Task12:
	ld a,(ix+VECTOR)
	cp 1
	jr z, Task12_throw
	cp 2
	jp z,Task12_hit
	Call Hold_Object
	Call Get_Key_Throw
	cp $BF
	jr nz,Task12_End

	ld (ix+VECTOR),1
	ld a,(direction)
	ld (ix+DIRECTION),a
	ld (ix+COUNTER),0
Task12_End:
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr nz,Task12_end_x ;
	ld hl,goomba_hold_animation
	Call Handle_Animation
Task12_end_x:
	Call Restore_Values
	ret
Task12_throw:
	ld a,9
	Call Handle_Obj_throw
	ret
Task12_hit:
	ld (ix),32
	ld (ix+DIRECTION),0
	jp _TaskEnd
	
Task13:	
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr nz,Task13_end
	ld a,(ix+6)
	cp 20
	jr z,Task13_delete
	inc a
	ld (ix+6),a
	ld d,(ix+H_YCOR)
	ld e,(ix+L_YCOR)
	dec de
	ld (ix+H_YCOR),d
	ld (ix+L_YCOR),e
	jr Task13_End
Task13_delete:
	ld (ix),0
Task13_end:
	Call Restore_Values
	ret
Task14:
	ld a,(ix+COUNTER2)
	cp 4
	jr z,Task14_Revert
	inc a
	ld (ix+COUNTER2),a
	ld a,(ix+DIRECTION)
	cp 1
	Call z,Task_Move_Left
	cp 2
	Call z,Task_Move_Right
	ex de,hl
	cp 1
	Call z,dec_hl
	cp 2
	Call z,inc_hl
	ex de,hl
	ld (ix+1),d
	ld (ix+2),e
	ld d,(ix+H_YCOR)
	ld e,(ix+L_YCOR)
	dec de
	ld (ix+H_YCOR),d
	ld (ix+L_YCOR),e
Task14_end:
	Call Restore_Values
	ret
Task14_Revert:
	ld a,(ix)
	cp 31
	Call z,Task14_grass
	cp 35
	Call z,Task14_turnip
	ld (ix+VECTOR),1
	ld (ix+COUNTER),0
	jr Task14_end
Task14_grass:
	ld (ix),27
	ret
Task14_turnip:
	ld (ix),34
	ret
	
Task15: ;squished goomba thing
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr nz,Task14_end
	Call Gravity_Handle
	jr Task14_End
	
Task16:
	ld a,(ix+VECTOR)
	cp 1
	jr z, Task16_throw

	Call Hold_Object
	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	cp $BF
	jr nz,Task16_End

	ld (ix+VECTOR),1
	ld a,(direction)
	ld (ix+DIRECTION),a
	ld (ix+COUNTER),0
Task16_End:

	Call Restore_Values
	ret
Task16_throw:
	ld a,(ix+COUNTER)
	inc a \ and 1 \ ld (ix+COUNTER),a
	or a
	jr nz,Task16_End

	ld d,(ix+H_XCOR)
	ld e,(ix+L_XCOR)
	ld a,e
	and 07
	cp 1 ; thing moves 2 pixels
	Call z,dec_de
	or a
	jr nz,_ychk2
	ex de,hl ;hl = xcor, ix can't directly interact with hl
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	ld a,e
	and 07
	or a
	Call Convert_X_tile
	or a
	Call Convert_y_tile
	ld h,a
	ld a,l
	ld c,e
	ld e,(ix + DIRECTION)
	dec e
	push ix
	Call CollisionChk
	pop ix
	or a
	jr nz,_killall
_ychk2:
	Call Y_convert_tile
	or a
	jr z,_task16_c	; if no collision occured, the object will not turn back to a
	; goomba thing



_killall:
	ld (ix),41
	ld b,40
	ld hl,objstruct
	ld de,9
_Task16_Collision:
	push hl
	ld a,(hl)
	cp 9
	jr z,_killenemies
	cp 10 
	jr z,_killenemies
	cp 38
	jr z,_killenemies
	cp 39
	jr z,_killenemies
	jr _Task16_next
_killenemies:
	ld (hl),32
	push de
	inc hl
	inc hl
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	dec de \ dec de \ dec de \ dec de
	ld (hl),e
	dec hl
	ld (hl),d
	pop de
_Task16_next:
	pop hl
	add hl,de
	djnz _Task16_Collision
	ld a,50
	Call create_explosion
	
	jr _Task16End
_task16_c:	
	Call Toss_object
_Task16End:
	Call Restore_Values
	ret

Task17:
	ld a,(ix+COUNTER)
	inc a \ and 1 \ ld (ix+COUNTER),a
	or a
	jr nz,Task17_Restore_end 
	
	
	ld hl,Jump_Animation
	Call Handle_Animation
	ld a,(ix+DIRECTION)
	inc a
	cp 26
	Call z,Task17_Reset
	ld (ix+DIRECTION),a
	cp 13
	jr c,Task17_Up
	ld d,(ix+H_YCOR)
	ld e,(ix+L_YCOR)
	inc de
	ld (ix+H_YCOR),d
	ld (ix+L_YCOR),e	
	jr Task17_Restore_end
	
Task17_Up:
	ld d,(ix+H_YCOR)
	ld e,(ix+L_YCOR)
	dec de
	ld (ix+H_YCOR),d
	ld (ix+L_YCOR),e
Task17_Restore_end:
	Call Restore_Values
	ret
Task17_Reset:
	xor a
	ret
Task22:
	push ix
	ld a,(lives)
	ld e,a
	ld d,0
	ld hl,Number_Table
	add hl,de \ add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	push de \ pop ix
	ld a,96-45
	ld l,1
	ld b,5
	Call PutSpriteXOR
	ld ix, livespic
	ld a,96-60
	ld l,0
	ld b,8
	Call PutSpriteXOR
	ld ix, livesx
	ld a,96-53
	ld l,0
	ld b,8
	Call PutSpriteXOR

	ld ix, heart
	ld a,3
	ld l,0
	ld b,8
	Call PutSpriteXOR
	ld ix, heart
	ld a,3
	ld l,10
	ld b,8
	Call PutSpriteXOR
	pop ix
	pop hl
	Call Restore_Values
	jp NextSprite
Task18:
	push ix
	ld a,(coins)
	cp 99
	Call z,Task18_Coin_Reset
	ld l,a
	ld h,0
	ld d,10
	Call Div_HL_D
	; HL = HL ÷ D, A = remainder
	push af
	ld e,l
	ld d,0
	ld hl,Number_Table
	add hl,de \ add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	push de \ pop ix
	ld a,96-9
	ld l,0
	ld b,5
	Call PutSpriteXOR
	pop af
	add a,a
	ld e,a
	ld d,0
	ld hl,Number_Table
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	push de \ pop ix
	ld a,96-5
	ld l,0
	ld b,5
	Call PutSpriteXOR
    ; A = x coordinate
; L = y coordinate
; B = number of rows
; IX = address of sprite
	ld ix, coin2
	ld a,96-18
	ld l,0
	ld b,8
	Call PutSpriteXOR
	pop ix
	pop hl
	Call Restore_Values
	jp NextSprite
Task18_Coin_Reset:
	xor a
	ld (coins),a
	ld a,(lives)
	inc a
	ld (lives),a
	ret
Task19:
	ld a,(ix+COUNTER2)
	cp 15 \ jr z,Task19_Delete
	inc a \ ld (ix+COUNTER2),a
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr nz,Task15_end
	ld hl,Explosion_Animation
	Call Handle_Animation
Task15_end:
	Call Restore_Values
	ret
Task19_Delete:
	ld (ix),0
	jr Task15_end
Task20:
	ld a,(ix+VECTOR)
	cp 1
	jr z,Task20_throw
	cp 2
	jp z,Task20_hit
	Call Hold_Object
	Call Get_Key_Throw
	cp $BF
	jr nz,Task20_End
	Call Handle_Vectors
Task20_End:
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr nz,Task20_end_x ;
	ld hl,Jump_hold_Animation
	Call Handle_Animation
Task20_end_x:
	Call Restore_Values
	ret
Task20_throw:
	ld a,38
	Call Handle_Obj_throw
	ret
Task20_hit:
	ld (ix),45
	ld (ix+DIRECTION),0
	ld (ix+COUNTER),3
	
	jp _TaskEnd
Task21:
	ld a,(ix+COUNTER)
	inc a \ and 3 \ ld (ix+COUNTER),a
	or a
	jr nz,Task21_end
	ld hl,Water_Animation
	Call Handle_Animation
Task21_end:
	Call Restore_Values
	ret
Task25:
	ld a,(ix+COUNTER)
	inc a \ and 15 \ ld (ix+COUNTER),a
	or a
	ld d,(ix+H_YCOR)
	ld e,(ix+L_YCOR)
	dec de
	ld (ix+H_YCOR),d
	ld (ix+L_YCOR),e
Task25_end:
	Call Restore_Values
	ret
	
;-----------------------------------------
;Object Routines
;-----------------------------------------
Create_explosion:
;a = pic
	ld b,(ix + H_YCOR)
	ld c,(ix + L_YCOR)
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)
	push af
	push bc \ push de
	Call Create_object
	pop de \ pop bc \ pop af \ push af \ push bc \ push de \ inc a \ Call Create_object
	pop de \ pop bc \ pop af \ push af \ push bc \ push de \ ld hl,6 \ add hl,bc \ ld b,h \ ld c,l
	ld hl,2 \ add hl,de \ ld d,h \ ld e,l
	Call Create_object
	pop de \ pop bc \ ld hl,6 \ add hl,bc \ ld b,h \ ld c,l
	ld hl,-2 \ add hl,de \ ld d,h \ ld e,l
	pop af \ inc a \ Call Create_object
	ret
Handle_Vectors:
	ld (ix+VECTOR),1
	ld a,(direction)
	ld (ix+DIRECTION),a
	ld (ix+COUNTER),0
	ret
Get_Key_Throw:
	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	ret
Handle_Obj_throw:
	push af ; this is the value of the returned object
	ld a,(ix+COUNTER)
	inc a \ and 1 \ ld (ix+COUNTER),a
	or a
	jp nz,_TaskEndThrow

	ld d,(ix+H_XCOR)
	ld e,(ix+L_XCOR)
	ld a,e
	and 07
	cp 1 ; thing moves 2 pixels
	Call z,dec_de
	or a
	jr nz,_ychk
	ex de,hl ;hl = xcor, ix can't directly interact with hl
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	ld a,e
	and 07
	or a
	Call Convert_X_tile
	or a
	Call Convert_y_tile
	ld h,a
	ld a,l
	ld c,e
	ld e,(ix + DIRECTION)
	dec e
	push ix
	Call CollisionChk
	pop ix
	or a
	jr nz,_revive	
	
_ychk:
	Call Y_convert_tile
	or a
	jr z,_task12_c	; if no collision occured, the object will not turn back to a
	; walkin goomba thing
_revive:
	pop af ; argument
	ld (ix),a
	ld a,(ix+DIRECTION)
	dec a
	ld (ix+DIRECTION),a
	jr _TaskEnd
_task12_c:	
	Call Toss_object
	ld b,40
	ld hl,objstruct
_Task12_Collision:
	push hl
	ld a,(hl)
	cp 9
	jr z,DoCollision
	cp 38
	jr z,DoCollision
	jr _Task12_next
DoCollision:
	Call Handle_Object_Collision
_Task12_next:
	pop hl
	ld de,9
	add hl,de
	djnz _Task12_Collision
_TaskEndThrow:
	pop af
_TaskEnd:
	Call Restore_Values
	ret
Task23:
	;ld a,(ix+COUNTER)
	;inc a \ and 1 \ ld (ix+COUNTER),a
	;or a
	;jr nz,Task23_end

	ld a,(ix + COUNTER2)
	ld l,a
	cp 25
	jr z,Force_decrement
	ld h,0
	ld de,parabolicx
	ld bc,parabolicy
	Call Handle_Parabola
	ld a,(ix + COUNTER2) \ inc a ; cp 23 \ jr nz,Task23_restore
	ld (ix+COUNTER2),a
	jr Task23_end
Force_decrement:
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	inc de \ inc de \ inc de
	ld (ix + H_YCOR),d
	ld (ix + L_YCOR),e
	
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)
	inc de
	ld (ix + H_XCOR),d
	ld (ix + L_XCOR),e
Task23_end:
	Call Restore_Values
	ret
Task24:
	;ld a,(ix+COUNTER)
	;inc a \ and 1 \ ld (ix+COUNTER),a
	;or a
	;jr nz,Task23_end

	ld a,(ix + COUNTER2)
	ld l,a
	cp 25
	jr z,Force_decrementx
	ld h,0
	ld de,parabolicxneg
	ld bc,parabolicy
	Call Handle_Parabola
	ld a,(ix + COUNTER2) \ inc a ; cp 23 \ jr nz,Task23_restore
	ld (ix+COUNTER2),a
	jr Task24_end
Force_decrementx:
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	inc de \ inc de \ inc de
	ld (ix + H_YCOR),d
	ld (ix + L_YCOR),e
	
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)
	dec de
	ld (ix + H_XCOR),d
	ld (ix + L_XCOR),e
Task24_end:
	Call Restore_Values
	ret

;----------------
Parabolic_Toss:
	ld a,(ix + ANIMATION)
	ld l,a
	cp 27
	jr z,curved
	ld h,0
	
	ld a,(ix+DIRECTION)
	cp 1
	Call z,lddeparabolicxneg_toss
	cp 2
	Call z, lddeparabolicx_toss  ;right
	
	ld bc,parabolicy_toss
	Call Handle_Parabola
	ld a,(ix + ANIMATION) \ inc a ; cp 23 \ jr nz,Task23_restore
	ld (ix+ANIMATION),a
	jr _endp
curved:
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	inc de \ inc de
	ld (ix + H_YCOR),d
	ld (ix + L_YCOR),e
	
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)
	inc de \ inc de
	ld (ix + H_XCOR),d
	ld (ix + L_XCOR),e
_endp:
	ret
lddeparabolicx_toss:
	ld de,parabolicx_toss
	ret
lddeparabolicxneg_toss:
	ld de,parabolicx_negtoss
	ret



Handle_Parabola:
	push hl
	add hl,de
	ld l,(hl) \ ld h,0
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)
	add hl,de
	ex de,hl
	ld (ix + H_XCOR),d
	ld (ix + L_XCOR),e
	
	pop hl
	;ld de,parabolicy
	ld d,b \ ld e,c
	add hl,de
	ld l,(hl) \ ld h,0
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	add hl,de
	ex de,hl
	ld (ix + H_YCOR),d
	ld (ix + L_YCOR),e
	ret
Dec_de:
	dec de
	ld (ix+H_XCOR),d
	ld (ix+L_XCOR),e
	xor a
	ret
Div_HL_D:
;courtesy to 28days
            ; HL = HL ÷ D, A = remainder
    XOR    A         ; Clear upper eight bits of AHL
    LD     B, 16      ; Sixteen bits in dividend
_loop:
    ADD    HL, HL     ; Do a SLA HL
    RLA              ; This moves the upper bits of the dividend into A
    JR     C, _overflow
    CP     D         ; Check if we can subtract the divisor
    JR     C, _skip   ; Carry means D > A
_overflow:
    SUB    D         ; Do subtraction for real this time
    INC    L         ; Set bit 0 of quotient
_skip:
    DJNZ   _loop
    RET
    
Y_convert_tile:
; reuturns a = 0 if  no collision of the y cor
	ld e,(ix+L_YCOR)
	ld a,e
	and 07
	or a
	jr nz,_ytile
	ld d,(ix+H_YCOR)
	or a
	Call Convert_Y_tile
	ld c,e
	ld d,(ix+H_XCOR)
	ld e,(ix+L_XCOR)
	ex de,hl
	ld a,l
	and 07
	or a
	Call Convert_X_tile
	ld h,a
	ld a,l
	ld e,DOWN
	push ix
	Call CollisionChk
	pop ix
	ret
_ytile:
	xor a
	ret
Handle_Object_Collision:
	inc hl
; hl = coor, de = coor
; returns  a = 0 if collision is false
;returns a = 1 if collision is true
	ld d,(hl)
	inc hl
	push hl
	ld e,(hl)
	ex de,hl
	ld d,(ix+1)
	ld e,(ix+2)
	Call Collision_Detect8
	pop hl
	or a
	ret z
	push hl
	inc hl
	ld d,(hl)
	inc hl
	ld e,(hl)
	ex de,hl
	ld d,(ix+3)
	ld e,(ix+4)
	Call Collision_detect8
	pop hl
	dec hl
	dec hl
	or a
	ret z
	ld (hl),30
	ld de,6
	add hl,de
	ld (hl),0
	ld (ix+VECTOR),2
	ret
Toss_Object:
	ld a,(ix+DIRECTION)
	cp 1
	Call z,Task_Move_Left
	cp 2
	Call z, Task_Move_Right
	ex de,hl
	cp 1
	Call z,Dec_hl
	cp 2
	Call z,Inc_hl
	ex de,hl
	ld (ix+H_XCOR),d
	ld (ix+L_XCOR),e
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	inc de
	ld (ix+H_YCOR),d
	ld (ix+L_YCOR),e
	ret
Hold_object:
	Call Convert_Blocky_X
	ex de,hl
	ld (ix+1),d
	ld (ix+2),e
	Call Convert_Blocky_Y
	ld de,-8
	add hl,de
	ex de,hl
	ld (ix+3),d
	ld (ix+4),e
	ret
Convert_Blocky_X:
	ld a,(Block_X)
	add a,a
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	ld a,(Block_X+1)
	dec a
	ld e,a
	ld d,0
	add hl,de
	ret
Convert_Blocky_Y:
	ld a,(Block_Y)
	add a,a
	ld l,a
	ld h,0
	add hl,hl
	add hl,hl
	ld a,(Block_Y+1)
	dec a
	ld e,a
	ld d,0
	add hl,de
	ret
Gravity_Handle:
	ld e,(ix+L_YCOR)
	ld a,e
	and 07
	or a
	jr nz,Handle_Gravity
	ld d,(ix+H_YCOR)
	or a
	Call Convert_Y_tile
	ld c,e
	ld d,(ix+H_XCOR)
	ld e,(ix+L_XCOR)
	ex de,hl
	ld a,l
	and 07
	or a
	Call Convert_X_tile
	ld h,a
	ld a,l
	ld e,DOWN
	push ix
	Call CollisionChk
	pop ix
	or a
	ret nz
Handle_Gravity:
	ld d,(ix+H_YCOR)
	ld e,(ix+L_YCOR)
	inc de
	ld (ix+H_YCOR),d
	ld (ix+L_YCOR),e
	ret

Left_Right_Movement:
	ld d,(ix+H_XCOR)
	ld e,(ix+L_XCOR)
	ld a,e
	and 07
	or a
	jr nz,Task5_Restore
	ex de,hl ;hl = xcor, ix can't directly interact with hl
	ld d,(ix + H_YCOR)
	ld e,(ix + L_YCOR)
	ld a,e
	and 07
	or a
	Call Convert_X_tile
	or a
	Call Convert_y_tile
	ld h,a
	ld a,l
	ld c,e
	ld e,(ix + DIRECTION)
	push ix
	Call CollisionChk
	pop ix
	or a
	jr z,Task5_Restore
	Call Reverse_Direction
	ret
Task5_Restore:
	ld a,(ix + DIRECTION)
	or a
	Call z,Task_Move_Left
	cp 1
	Call z,Task_Move_Right
	ld (ix + H_XCOR),d
	ld (ix + L_XCOR),e
	ret
Handle_Animation:
;hl = pointer to animation
	ld a,(hl)
	ld b,(ix + ANIMATION)
	inc b
	cp b
	jr nz,_Cont_animation
	ld b,0
_Cont_animation:
	ld (ix+ANIMATION),b
	ld e,b
	ld d,0
	add hl,de
	inc hl
	ld a,(hl)
	ld (ix),a
	ret
Restore_Values:
	ld a,(ix)
	ld d,(ix+1)
	ld e,(ix+2)
	ld b,(ix+3)
	ld c,(ix+4)
	ret
	
Convert_X_tile:
;hl = xcor
	srl h \ rr l \ srl h \ rr l \ srl h \ rr l
	ret
Convert_Y_tile:
;de = ycor
	srl d \ rr e \ srl d \ rr e \ srl d \ rr e
	ret
Reverse_Direction:
	ld a,(ix + DIRECTION)
	inc a
	and 01
	ld (ix + DIRECTION),a
	ret
Task_Move_Left:
; decrements the xcor
;returns xcor in register DE
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)
	dec de
	ret
Task_Move_Right:
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)
	inc de
	ret
;-----------------------------------------
;Collision Check
;-----------------------------------------
; hl = coor, de = coor
; returns  a = 0 if collision is false
;returns a = 1 if collision is true
Collision_Detect8:
	or a
	sbc hl,de
	add hl,de
	jr c,HL_LESS_DE
	jr z,Collision_8
HL_GREATER_DE:
	or a
	sbc hl,de
	ld a,l
	cp 8
	jr c,Collision_8
	xor a
	ret
HL_LESS_DE:
	ex de,hl
	or a
	sbc hl,de
	ld a,l
	cp 8
	jr c,Collision_8
	xor a
	ret
Collision_8:
	ld a,1
	ret

Collision_Obj:
;hl = xcor
;de = ycor
	ld b,40
	ld ix,objstruct
_col_loop:
	push bc
	push hl  ;xcor
	push de  ;ycor
	xor a
	ld (lcd_counteR),a
	ld a,(ix)
	or a
	jr z,_col_no_obj
	ld d,(ix+1) ;xcor of obj
	ld e,(ix+2) ;xcor hi of obj
	ex de,hl
	;Call Handle_LCD
	;ld a,(lcd_counter)
	;cp 1
	;jr z,_col_no_obj
	ex de,hl
	Call Collision_detect8
	cp 1
	jr nz, _col_no_obj
	ld d,(ix+3)
	ld e,(ix+4)
	pop hl  ;de
	ex de,hl
	;Call Handle_LCD
	;ld a,(lcd_counter)
	;cp 1
	;jr z,_col_no_obj
	ex de,hl	
	push hl
	Call Collision_detect8
	cp 1
	jr nz, _col_no_obj	
	ld hl,_col_no_obj
	push hl
	ld a,(ix)
	add a,a
	ld e,a
	ld d,0
	ld hl,Collision_Table
	add hl,de
	ld e,(hl)
	inc hl
	ld d,(hl)
	push de
	ret
_col_no_obj:
	pop de
	pop hl
	ld bc,9
	add ix,bc
	pop bc
	djnz _col_loop
	ret
	
Collision1:
	ld (ix),41
	ld a,(coins)
	inc a
	ld (coins),a
	ld a,52
	call create_explosion
	ret
Collision2:
	Call Get_Char_Coordinates
	ld a,1
	ld (Collision_C),a
	ex de,hl  ; hl = ycor
	ld d,(ix + H_YCOR) ; de = ycor of object
	ld e,(ix + L_YCOR)
	or a
	sbc hl,de
	ld a,l
	cp 7
	ret nz
	ld a,(Jump_C)
	or a
	ret z
	ld b,(ix + H_YCOR)
	ld c,(ix + L_YCOR)
	ld hl,-8
	add hl,bc
	ld b,h
	ld c,l
	ld d,(ix + H_XCOR)
	ld e,(ix + L_XCOR)	
	ld a,7
	Call Create_Object
	ld a,52
	Call create_explosion
	ld a,(ix+COIN_COUNT)
	cp 1
	jr z,Delete_Block
	inc a
	ld (ix+COIN_COUNT),a
	ret
Delete_Block:
	ld (ix),17
	ret
Collision3:
	Call Get_Char_Coordinates
	ld a,1
	ld (Collision_C),a  ; hl = char x, de = obj x
	ld d,(ix+1)
	ld e,(ix+2)
	or a
	sbc hl,de
	add hl,de
	jr c,Push_Right
Push_Left:
	dec de
	ld (ix+1),d
	ld (ix+2),e
	ret
Push_Right:
	inc de
	ld (ix+1),d
	ld (ix+2),e
	ret
Collision4:
	ret
Collision5:
	ld a,(Invul_C)
	or a
	ret nz
	ld a,1
	ld (Collision_C),a	
	Call Get_Char_Coordinates
	;ld a,1
	;ld (Collision_C),a
	ex de,hl  ; hl = ycor
	ld d,(ix + H_YCOR) ; de = ycor of object
	ld e,(ix + L_YCOR)
	ex de,hl
	or a
	sbc hl,de
	ld a,l
	cp 7
	jr nz,Collision5_Damage
	Call Get_Char_Coordinates
	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	cp $7F
	jr nz,Handle_Vector_obj
	ld e,DOWN
	push ix
	Call handle_collision_ud
	pop ix
	or a  ; cp 0, if 0 = no object below it.
	jr nz,Handle_Vector_Obj
	
	ld (ix),28
	ld (ix+VECTOR),0
	ld (ix+COUNTER),0
Handle_Vector_obj:
	ld a,(ix+COUNTER)
	or a
	ret z
	ld a,(ix+DIRECTION)
	push af
	cp LEFT
	Call z,Left_Skip
	pop af
	cp RIGHT
	Call z,Right_skip
	ret
Collision5_Damage:
	ld a,1
	ld (Invul_C),a
	ret
Collision6:
	ret
Collision7:
	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	cp $7F
	ret nz
	
	ld a,50
	call create_explosion
	ld (ix),27
	ld (ix+VECTOR),0
	ret
Collision9:
	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	cp $7F
	ret nz
	ld d,(ix+H_YCOR)
	ld e,(ix+L_YCOR)
	ex de,hl
	ld d,(ix+H_XCOR)
	ld e,(ix+L_XCOR)
	or a \ srl d \ rr e\ srl d \ rr e\ srl d \ rr e
	or a \ srl h \ rr l\ srl h \ rr l\ srl h \ rr l ; divide by 8
	; hl = ycor, de = xcor 
	push hl
	ld hl,Matrix
	add hl,de
	pop bc
	ld b,c
	ld de,WIDTH
_collisionloop9:
	add hl,de
	djnz _collisionloop9
	ld (hl),0

	ld (ix),37
	ld (ix+VECTOR),0
	ret
Collision8:
	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	cp $7F
	ret nz
	ld a,50
	call create_explosion
	ld (ix),34
	ld (ix+VECTOR),0
	ret
Collision10:
	ld a,(Invul_C)
	or a
	ret nz
	ld a,1
	ld (Collision_C),a	
	Call Get_Char_Coordinates

	ld a,$FF
	out (1),a
	nop \ nop
	ld a,$DF 
	out (1),a
	nop \ nop
	in a,(1)
	cp $7F
	jr nz,HandleV10
	ld e,DOWN
	push ix
	Call handle_collision_ud
	pop ix
	or a  ; cp 0, if 0 = no object below it.
	jr nz,HandleV10
	
	ld (ix),43
	ld (ix+VECTOR),0
	ld (ix+COUNTER),0	
HandleV10:
	Call Get_Char_Coordinates	
	;ld a,1
	;ld (Collision_C),a
	ex de,hl  ; hl = ycor
	ld d,(ix + H_YCOR) ; de = ycor of object
	ld e,(ix + L_YCOR)
	ex de,hl
	or a
	sbc hl,de
	ld a,l
	cp 6
	jr z,Contx
	cp 7
	jr z,Contx
	jr Collision10_Damage
Contx:

	;ld a,(ix+COUNTER)
	;or a
	;ret z
	;ld a,(ix+DIRECTION)
	;cp 13
	;ret nc
	Call Up_Skip
	ret
Collision10_Damage:
	ld a,1
	ld (Invul_C),a
	ret
	
	
Get_Char_Coordinates:
	pop hl
	ld (Pointer),hl
	pop bc ; return address
	pop de ;ycor
	pop hl ;xcor
	push hl
	push de
	push bc
	ld bc,(Pointer)
	push bc
	ret
Pointer:
.dw 0
Create_Object:
; bc = ycor
; de = xcor
; a = id
	push de
	push bc
	push af
	ld b,40
	ld hl,Objstruct
	ld de,9
_find_loopx:
	ld a,(hl)
	cp 0
	jr z,EmptyObjFoundx
	add hl,de
	djnz _find_loopx
	pop af
	pop bc
	pop de
	ret
EmptyObjFoundx:
	ld a,40
	sub b
	ld (_ptr),a
	pop af
	pop bc
	
	ld (hl),a
	inc hl
	pop de
	ld (hl),d
	inc hl
	ld (hl),e
	inc hl
	ld (hl),b
	inc hl
	ld (hl),c
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	inc hl
	ld (hl),0
	ld a,(_ptr)
	add a,a
	ld l,a
	ld h,0
	ld de,CoordStruct
	add hl,de
	ld (hl),0
	inc hl
	ld (hl),0 ; unexisting location
	ret
	
;-----------------------------------------
;CHECK ROUTINES
;-----------------------------------------

; checks are used when the offset on a side is equal and only equal to 1

; call this routine BEFORE scrolling is achieved, BUT ONLY CALL WHEN SCROLLING IS OCCURING

; setups scroll, layered objects DEFINED BY  5>= ARE OBJECTS THAT HAVE 5
Check_ObjR:	
	xor a
	ld (Temp3),a
	ld a,(Right_Max)	
	ld d,0
	ld e,a    ; check on the right side
	ld hl,Matrix_L2
	add hl,de
	ld de,WIDTH
	ld a,(Up_Max)
	or a
	jr z,SkippAdd2
	ld b,a
_Offset_Top22:
	add hl,de   ; gets top offset
	djnz _Offset_Top22
SkippAdd2:	
	; used to be ld b,8... but it can be 9 if its scrolled down
	ld a,(Up_Max)
	ld b,a
	ld a,(Down_Max)
	sub b
	ld b,a
	inc b
_Rchk:
	ld a,(hl)
	cp 5
	jr c,NextR
	ld (Saved),a  ; a= object picture pointer
	ld (hl),0 ; temporarily delete the object so it can't be created again until it is deleted
	push hl
	ld a,(Right_Max)	
	ld h,0
	ld l,a
	Call CreateNewObj
	pop hl
	ld de,WIDTH
NextR:
	add hl,de	
	djnz _Rchk
	ret
Check_ObjL:             ; check on the left side
	xor a
	ld (Temp3),a
	ld a,(Left_Max)
	ld d,0
	ld e,a
	ld hl,Matrix_L2
	add hl,de
	ld de,WIDTH
	ld a,(Up_Max)
	or a
	jr z,SkippAdd
	ld b,a
_Offset_Top2:
	add hl,de   ; gets top offset
	djnz _Offset_Top2
SkippAdd:
	; used to be ld b,8... but it can be 9 if its scrolled down
	ld a,(Up_Max)
	ld b,a
	ld a,(Down_Max)
	sub b
	ld b,a
	inc b
_Lchk:
	ld a,(hl)
	cp 5
	jr c,NextL
	ld (Saved),a
	ld (hl),0
	push hl
	ld a,(Left_Max)
	ld h,0
	ld l,a
	Call CreateNewObj
	pop hl
	ld de,WIDTH
NextL:
	add hl,de	
	djnz _Lchk
	ret
Check_ObjD:             ; check on the left side
	ld a,(Up_Max)
	ld (TempVar),a
	xor a
	ld (Up_Max),a
	ld a,(Down_Max)
	ld (Temp3),a
	ld a,(Left_Max)
	ld d,0
	ld e,a
	ld hl,Matrix_L2
	add hl,de
	ld de,WIDTH
	ld a,(Down_Max)
	or a
	jr z,SkippAddD
	ld b,a
_Offset_TopD:
	add hl,de   ; gets top offset
	djnz _Offset_TopD
SkippAddD:
	; used to be ld b,11... but it can be 12 if its scrolled down
	ld b,13
_Dchk:
	ld a,13
	;xor a
	sub b
	ld (Tempz),a
	ld a,(hl)
	cp 5
	jr c,NextD
	ld (Saved),a
	push bc
	ld a,0
	ld b,a
	ld a,(Down_Max)
	sub b
	ld b,a
	inc b    ; make it zero
	ld (hl),0
	push hl
	ld a,(Left_Max)
	ld h,0
	ld l,a
	ld a,(Tempz)
	add a,l
	ld l,a
	
	Call CreateNewObj
	pop hl
	pop bc

	
NextD:
	inc hl
	djnz _Dchk
	ld a,(TempVar)
	ld (Up_Max),a
	ret	
	
Check_ObjU:             ; check on the up
	ld a,(Up_Max)
	ld (Temp3),a

	ld a,(Up_Max)
	ld (TempVar),a
	xor a
	ld (Up_Max),a
	ld a,(Left_Max)
	ld d,0
	ld e,a
	ld hl,Matrix_L2
	add hl,de
	ld de,WIDTH
	ld a,(TempVar)
	or a
	jr z,SkippAddU
	ld b,a
_Offset_TopU:
	add hl,de   ; gets top offset
	djnz _Offset_TopU
SkippAddU:
	; used to be ld b,8... but it can be 9 if its scrolled down
	ld b,12
_Uchk:
	ld a,12
	sub b
	ld (Tempz),a
	ld a,(hl)
	cp 5
	jr c,NextU
	ld (Saved),a
	push bc
	ld a,0
	ld b,a
	ld a,(Down_Max)
	sub b
	ld b,a
	inc b    ; make it zero ;o
	ld (hl),0
	push hl
	ld a,(Left_Max)
	ld h,0
	ld l,a
	ld a,(Tempz)
	add a,l
	ld l,a
	Call CreateNewObj
	pop hl
	pop bc
NextU:
	inc hl
	djnz _Uchk
	ld a,(TempVar)
	ld (Up_Max),a
	ret	

;-----------------------------------------------
;MAIN CHARACTER
;-----------------------------------------------



Coins:
	.db 0
Invul_C:
	.db 0
Collision_C:
.db 0
Direction_Collision:
	.db 0 ; 1-left, 2-rught, 3-up, 4-down, 0-no direction
Jump_C:
.db 0
Grav_C:
.db 0

MoveRight:

	ld a,(Block_X+1)
	inc a
	cp 9
	Call z,FixBlockR
	ld (Block_X+1),a

	ld a,(Block_XX+1)
	inc a
	cp 9
	Call z,FixBlockR2
	ld (Block_XX+1),a


	ret
FixBlockR:
	ld a,(Block_X)
	inc a
	ld (BLock_X),a
	ld a,1
	ret
FixBlockR2:
	ld a,(Block_XX)
	inc a
	ld (BLock_XX),a
	ld a,1
	ret



MoveLeft:

	ld a,(Block_X+1)
	dec a
	Call z,FixBlockL
	ld (Block_X+1),a

	ld a,(Block_XX+1)
	dec a
	Call z,FixBlockL2
	ld (Block_XX+1),a
	ret
FixBlockL:
	ld a,(Block_X)
	dec a
	ld (BLock_X),a
	ld a,8
	ret
FixBlockL2:
	ld a,(Block_XX)
	dec a
	ld (BLock_XX),a
	ld a,8
	ret


MoveUp:

	ld a,(Block_Y+1)
	dec a
	Call z,FixBlockU
	ld (Block_Y+1),a


	ld a,(Block_YY+1)
	dec a
	Call z,FixBlockU2
	ld (Block_YY+1),a
	ret
FixBlockU:
	ld a,(Block_Y)
	dec a
	ld (BLock_Y),a
	ld a,8
	ret
FixBlockU2:
	ld a,(Block_YY)
	dec a
	ld (BLock_YY),a
	ld a,8
	ret

MoveDown:

	ld a,(Block_Y+1)
	inc a
	cp 9
	Call z,FixBlockD
	ld (Block_Y+1),a

	ld a,(Block_YY+1)
	inc a
	cp 9
	Call z,FixBlockD2
	ld (Block_YY+1),a
	ret
FixBlockD:
	ld a,(Block_Y)
	inc a
	ld (BLock_Y),a
	ld a,1
	ret
FixBlockD2:
	ld a,(Block_YY)
	inc a
	ld (BLock_YY),a
	ld a,1
	ret
DrawChar:
	ld a,(Up_Max)
	ld b,a
	ld a,(Block_Y)
	sub b
	add a,a
	add a,a
	add a,a
	ld c,a
	ld a,(Up_Offset)
	ld b,a
	ld a,(Block_Y+1)
	sub b
	add a,c
	ld l,a
	ld a,(Left_Max)
	ld b,a
	ld a,(Block_X)
	sub b
	add a,a
	add a,a
	add a,a
	ld c,a
	ld a,(Left_Offset)
	ld b,a
	ld a,(Block_X+1)
	sub b
	add a,c
	ld b,8
	push de
	pop ix
	call PutSpriteXOR
	ret
	
    ; A = x coordinate
; L = y coordinate
; B = number of rows
; IX = address of sprite




      ; Arguments  de = Sprite image, hl = screen buffer
	  push de
	  
	  ld a,5 ;(Block_Y)
	  or a
	  jr z, SkipThis
	  ld b,a
	  ld de,96
Addd:
	add hl,de
	djnz Addd
SkipThis:
	ld e, 6
	ld d,0
	add hl,de
	
	ld a,1 ;(Block_Y+1)
	dec a
	jr z,Awww
	ld b,a
	ld e,12
	ld d,0
More:
	add hl,de
	djnz More
	  
Awww:      
	pop de
      ld b,8
Drawd: 
     ld a,(de)
	 xor (hl)
      ld (hl),a
      inc de
      push de
      ld de,12
      add hl,de
      pop de
      djnz Drawd
      ret
      
	
Interrupt_Start:
    ex af,af'
    exx
	ld a,(delay_c);
	inc a
	ld (delay_C),a
Not2seconds:
    LD     A,%00001000   ;acknowledge
    OUT    (3),A
    LD     A,%00001010   ;Normal timer only
    OUT    (3),A
	ld a,%00000110		;Slowest frequency, ~110hz
	out (4),a

    exx
    ex af,af'
    ei
    ret
Interrupt_End:

;-----------------------------------------
Collision_SubRoutines:
;-----------------------------------------
;-----------------------------------------
data:
;Object data
;-----------------------------------------
Task_Table:
.db 0,0
.db 0,0
.db 0,0
.db 0,0
.db 0,0
.dw Task1
.dw Task2
.dw Task3
.dw Task3
.dw Task5 ;9
.dw Task5 ;10
.dw Task6 ;11
.dw Task7 ;12
.dw Task8 ;13
.dw Task8 ;14
.dw Task8 ;15
.dw Task8 ;16
.dw Task4 ;17
.dw Task9 ;18
.dw Task2 ;19
.dw Task6
.dw Task6
.dw Task6
.dw Task6
.dw Task6
.dw Task10
.dw Task10
.dw Task11
.dw Task12
.dw Task12
.dw Task13
.dw Task14 ;31
.dw Task15
.dw Task10_end ;33
.dw Task11
.dw Task14 ;35
.dw Task10_end
.dw Task16
.dw Task17
.dw Task17
.dw Task18
.dw Task19
.dw Task19
.dw Task20
.dw Task20
.dw Task2
.dw Task21
.dw Task21
.dw Task21
.dw Task22
.dw Task23
.dw Task24
.dw Task23
.dw Task24
Collision_Table:
.db 0,0
.db 0,0
.db 0,0
.db 0,0
.db 0,0
.dw Collision1
.dw Collision1
.dw Collision1
.dw Collision1
.dw Collision5
.dw Collision5
.dw Collision2
.dw Collision3
.dw Collision1
.dw Collision1
.dw Collision1
.dw Collision1
.dw Collision4
.dw Collision4
.dw Collision6 ;19
.dw Collision2
.dw Collision2
.dw Collision2
.dw Collision2
.dw Collision2
.dw Collision7
.dw Collision7
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw COllision4 ;32
.dw Collision8 ;33
.dw Collision4 ;34
.dw Collision4
.dw Collision9
.dw Collision4
.dw Collision10
.dw Collision10
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision6
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
.dw Collision4
CoordStruct:

.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
.db 0,0,0,0,0,0,0,0,0,0
ObjStruct:

;ObjStruct 
;{
;char status // 0 = unexistanant, also tells task and picture (however, a task for object X can call a task ffrom a different object, allowing different pics
;with same tasks
;int xcor // xcor, max of (29 * 8) + 8
;char ycor // ycor, max of 8*7 + 7 = 63
;char reserved;
;char reserved;
;char reserved;
;char reserved;
;}
.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0



.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0


.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0


.db 0
.db 0,0
.db 0
.db 0 ; 8
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0


.db 0
.db 0,0
.db 0
.db 0 ; 8
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 ; 8
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0


.db 0
.db 0,0
.db 0
.db 0 ; 8
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 ; 8
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0


.db 0
.db 0,0
.db 0
.db 0 ; 8
.db 0,0,0
.db 0
.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0

.db 0
.db 0,0
.db 0
.db 0 
.db 0,0,0
.db 0


.db 0
.db 0,0
.db 0
.db 0 ; 8
.db 0,0,0
.db 0
;-----------------------------------------
;Object variables
;-----------------------------------------
h_count:
.db 0
_ptr:          ; pointer to objstruct
	.db 0
parabolicx: 
.db 00,01,00,00,01,1,00,01,01,01,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1
parabolicxneg:
.db 00,-1,00,00,-1,-1,00,-1,-1,-1,-2,-1,-1,-2,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1
parabolicy:
.db -1,-1,0,-1,-1,0,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2
parabolicx_toss: 
.db 01,01,01,01,01,1,01,01,01,01,1,1,1,1,1,1,1,1,2,1,2,1,2,2,2,2,2
parabolicy_toss:
.db 0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,1,1,1,1,1,2,2
parabolicx_negtoss:
.db 0-1,0-1,0-1,0-1,0-1,-1,0-1,0-1,0-1,0-1,-1,-1,-1,-1,-1,-1,-1,-1,-2,-1,-2,-1,-2,-2,-2,-2,-2
collision_ptr_x:
.db -1,1,0,0
collision_ptr_y:
.db 0,0,-1,1
collision_tbl:
.db 0,0,1,1
goomba_hold_animation:
.db 2
.db 28,29
Goomba_Animation:
.db 2
.db 9,10
Coin_Animation:
.db 2
.db 7,8
Explosion_Animation:
.db 2 
.db 41,42
BeetleL_Animation:
.db 2
.db 13,14
BeetleR_Animation:
.db 2
.db 15,16
Question_Animation:
.db 5
.db 20,21,22,23,24
Grass_animation:
.db 2
.db 25,26
Jump_Animation
.db 2
.db 38,39
Jump_hold_Animation:
.db 2
.db 43,44
Water_Animation:
.db 3
.db 46,47,48


;-----------------------------------------
;Sprite table & Matrix
;-----------------------------------------
Delete_Table:
; 0 = do not reset object, keep the object on the que until something happens
; 1 = reset object at screen edge
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1 ;5
.db 1 ;6
.db 1 ;7
.db 1 ;8
.db 1 ;9
.db 1 ;10
.db 0 ;11
.db 0 ;12
.db 1 ;13
.db 1 ;14
.db 1 ;15
.db 1 ;16
.db 1 ;17
.db 1 ;18
.db 1 ;19
.db 0
.db 0
.db 0
.db 0
.db 0
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
Restore_Table:
; 0 = when the object is deleted, do not put it back to the tile map
; 1 = restore object back to the tile map
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1 ;5
.db 1 ;6
.db 1 ;7
.db 1 ;8
.db 1 ;9
.db 1 ;10
.db 1 ;11
.db 1 ;12
.db 1 ;13
.db 1 ;14
.db 1 ;15
.db 1 ;16
.db 1 ;17
.db 0 ;18
.db 0 ;19
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 1
.db 0
.db 0
.db 0
.db 0 ;30
.db 0
.db 0
.db 1
.db 0
.db 0
.db 1
.db 0
.db 1 ; 38
.db 1
.db 0
.db 0
.db 0 ;42
.db 0
.db 0
.db 0
.db 1
.db 1 ;47
.db 1
.db 1
.db 1
.dw 1
.dw 1
.dw 1
SpriteAddressLUT:
.dw Blank ;0
.dw floor  ;1
.dw floor_leftside   ;2
.dw floor_rightside ;3
.dw Wallx ; 4
.dw Pipe ;5
.dw plant ; 6
.dw plant_longer ;7
.dw cloud_left
.dw cloud_right ;9
.dw fake_blank ;10
.dw Left_wall
.dw Right_wall
.dw Left_Corner
.dw Right_Corner
.dw Top_Wall ;15
.dw Tree_Top
.dw Tree_base
.dw Door1 ;18
.dw Door2 ;19
.dw Pillar_bottom ;20
.dw Pillar_top ;21
.dw log_left ; 22
.dw log_r ; 23

SpriteAddressLUTx:
.dw Blank ;0
.dw Wall  ;1
.dw Box   ;2
.dw Smile ;3
.dw blank ;4
.dw chimwa ;5
.dw creme ;6
.dw coin1 ;7
.dw coin2 ; 8
.dw Goomba ;9
.dw Goomba2 ;10
.dw Super_Block ;11
.dw Push_Block ;12
.dw BeetleL ;13
.dw BeetleL2 ;14
.dw BeetleR ;15
.dw BeetleR2 ;16
.dw wallx ;17
.dw Shell ;18
.dw Squish_Goomba ;19
.dw QuestionBlock1
.dw QuestionBlock3
.dw QuestionBlock5
.dw QuestionBlock7
.dw QuestionBlock8
.dw Plant1 ;25
.dw Plant2 ;26
.dw Plant1 ;27
.dw Goomba_Hold ;28
.dw Goomba_Hold2 ;29
.dw Ten_Points
.dw Plant1 ;31
.dw Squish_Goomba ;32
.dw Turnip_top ;33
.dw Turnip ;34
.dw Turnip ;35
.dw pow ;36
.dw pow ;37
.dw Jumper ;38
.dw Jumper2
.dw Blank
.dw Explosion
.dw Explosion2 ;42
.dw Jumper_Hold ;43
.dw Jumper_Hold2 ;44
.dw Jumpy_Splat ;45
.dw Water1 ; 46
.dw Water2 ;47
.dw Water3 ; 48
.dw Blank
.dw Debris ;50
.dw Debris
.dw Dimond ; 52
.dw Dimond
Matrix:         ;s
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,08,09,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,08,09,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,04,00,00,04,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,22,01,01,01,01,01,01,01,01,01,01,23,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,13,15,15,15,15,14,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,08,09,00,00,00,00,13,15,14,00,00,00,00,00,00,13,15,15,15,15,14,00,22,01,23,00,00,22,23,00,13,15,14
.db 00,00,00,00,08,09,00,00,00,16,00,00,00,00,00,00,00,08,09,00,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,08,09,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,12,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,11,00,12
.db 13,15,14,00,00,00,00,16,00,17,08,09,00,00,00,00,00,00,00,00,00,00,08,09,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,13,15,14,00,12,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,11,00,12
.db 11,00,12,00,00,00,00,17,00,17,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,08,09,00,00,00,00,00,00,10,00,11,00,12,00,12,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,11,00,12
.db 11,00,12,00,00,00,00,17,00,17,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,00,00,00,00,00,21,00,00,00,00,11,00,13,15,15,14,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,11,00,12
.db 11,18,12,00,00,00,00,17,00,17,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,21,00,00,00,00,10,00,00,00,00,20,00,00,00,00,11,00,11,00,00,12,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,00,00,00,00,00,11,00,12
.db 11,19,12,00,00,00,00,17,00,17,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,00,00,00,12,00,00,00,00,20,00,00,00,00,21,00,00,00,00,20,00,00,00,00,11,00,11,00,00,12,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,12
.db 01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,00,00,12,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,12
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,12
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01,01
Matrix_L2: ; The enemy mask
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,07,07,07,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,25,00,25,00,00,09,00,00,00,00,00,00,00,00,00,07,07,07,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,48,48,48,48,48,46,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,33,00,00,00,46,46,46,46,46,46,00,00,00,00,00,00,48,48,48,48,48,48,48,48,48,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,47,47,47,47,47,46,00,00,00,00,00,00,46,46,46,46,46,46,46,46,46,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,07,07,07,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,11,00,00,00,00,00,00,48,48,48,48,48,46,00,00,00,00,00,00,47,47,47,47,47,47,47,47,47,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,47,47,47,47,00,00,00,00,00,00,00,46,46,46,46,46,46,46,46,46,00,00,00
.db 40,49,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,36,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,48,48,48,48,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,25,00,00,33,00,09,00,09,00,00,25,00,00,00,25,00,00,00,00,00,07,07,07,00,00,00,00,00,00,00,00,00,00,00,09,00,00,38,00,38,00,00,00,00,25,00,00,00,00,00,00,00,46,46,46,46,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,47,47,47,47,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00


.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00
.db 0
;-----------------------------------------
;Sprites
;-----------------------------------------
debris:
.db $00,$00,$18,$2C,$3C,$18,$00,$00
dimond:
.db $00,$00,$08,$14,$22,$14,$08,$00


heart:
.db $66,$99,$C1,$C1,$62,$62,$34,$18

LOG_R:
.db $FE,$85,$25,$05,$05,$55,$AD,$FE
.db 1


livesx:
.db $00,$22,$14,$08,$14,$22,$00,$00


livespic:
.db $00,$7E,$A9,$B1,$A9,$7E,$00,$00


log_left:
.db $7F,$A1,$A4,$A0,$A0,$AA,$B5,$7F
.db 1
Jumpy_Splat:
.db $00,$00,$00,$24,$3C,$42,$A5,$FF
Blob_Jump:
.db $3C,$66,$A5,$81,$99,$81,$66,$99

Water1:
.db $81,$5A,$24,$81,$5A,$24,$81,$5A

Water2:
.db $24,$81,$5A,$24,$81,$5A,$24,$81
Water3:
.db $5A,$24,$81,$5A,$24,$81,$5A,$24






explosion:
.db $91,$52,$00,$03,$C0,$00,$4A,$89
explosion2:

.db $08,$08,$00,$C0,$03,$00,$10,$10
Jumper:
.db $42,$BD,$81,$A5,$81,$FF,$42,$42
Jumper2:
.db $00,$FF,$81,$A5,$81,$FF,$42,$66

Jumper_hold:
.db $42,$42,$FF,$81,$A5,$81,$BD,$42
Jumper_hold2:
.db $66,$42,$FF,$81,$A5,$81,$FF,$00


Pow:
.db $7E,$FF,$D5,$AB,$D5,$AB,$FF,$7E


Turnip:
.db $34,$18,$3C,$42,$81,$42,$24,$18


Turnip_top:
.db $00,$00,$00,$00,$00,$44,$34,$18


Ten_Points:
.db $00,$24,$6A,$2A,$2A,$24,$00,$00


Plant1:
.db $00,$00,$00,$14,$0A,$4A,$2C,$1C
Plant2:
.db $00,$00,$00,$28,$50,$52,$34,$38

Pillar_bottom:
.db $E1,$87,$99,$E1,$87,$99,$E1,$81
.db 1
Pillar_top:
.db $7E,$AB,$D5,$87,$99,$E1,$87,$99
.db 1
door1:
.db $FF,$81,$85,$85,$85,$BD,$81,$81
.db 0
door2:
.db $81,$81,$85,$85,$85,$BD,$81,$FF
.db 0

tree_base:
.db $18,$24,$18,$24,$18,$24,$18,$24
.db 0
tree_top:
.db $00,$4E,$B2,$F4,$5A,$BD,$99,$5A
.db 0

QuestionBlock1:
.db $7E,$99,$A5,$85,$99,$81,$91,$7E
QuestionBlock3:
.db $7E,$E1,$91,$91,$E1,$81,$C1,$7E
QuestionBlock5:
.db $7E,$81,$C1,$C1,$81,$81,$81,$7E
QuestionBlock7:
.db $7E,$83,$85,$81,$83,$81,$83,$7E
QuestionBlock8:
.db $7E,$8D,$93,$83,$8D,$81,$89,$7E
Squish_Goomba:
.db %00000000
.db %00000000
.db %00000000
.db %01111110
.db %10100101
.db %10000001
.db %10011001
.db %01111110
Shell:
.db %00000000
.db %00111100
.db %01101110
.db %01010110
.db %11101011
.db %11010101
.db %10101011
.db %01111110
BeetleR: ; object 13\14
.db %01111000
.db %10101100
.db %11010100
.db %10100110
.db %11111001
.db %10000011
.db %10111100
.db %01000010
BeetleR2:
.db %01111000
.db %10101100
.db %11010100
.db %10100110
.db %11111001
.db %10000011
.db %11110100
.db %01001000
BeetleL:
.db %00011110
.db %00110101
.db %00101011
.db %01100101
.db %10011111
.db %11000001
.db %00111101
.db %01000010
BeetleL2:
.db %00011110
.db %00110101
.db %00101011
.db %01100101
.db %10011111
.db %11000001
.db %00101111
.db %00010010
Push_Block: ;12, object
.db %01111110
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %01111110

fake_blank:
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db 1
Blank:
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000

.db 0
Left_Wall:
.db $80,$80,$80,$80,$80,$80,$80,$80
.db 0
Right_Wall:
.db $01,$01,$01,$01,$01,$01,$01,$01
.db 0
Top_wall:
.db $FF,$00,$00,$00,$00,$00,$00,$00
.db 1
Left_corner:
.db $3F,$40,$80,$80,$80,$80,$80,$80
.db 1	

Right_Corner:
.db $FC,$02,$01,$01,$01,$01,$01,$01
.db 1





floor:

.db $FF,$00,$04,$40,$00,$AA,$55,$FF
.db 1
floor_leftside:
.db %01111111
.db %10000000
.db %11000011
.db %10111100
.db %10000000
.db %10000000
.db %10000000
.db %01111111
.db 1
floor_rightside:
.db %11111110
.db %00000001
.db %11000011
.db %00111101
.db %00000001
.db %00000001
.db %00000001
.db %11111110
.db 1
Wallx:
.db %01111110
.db %11010101
.db %10101011
.db %11010101
.db %10101011;4
.db %11010101
.db %10101011
.db %01111110
.db 1
pipe:
.db %11111111
.db %01000010
.db %01000010
.db %01000010
.db %01000010
.db %01000010
.db %01000010 ;5
.db %01000010 ;5
.db 1
plant:
.db %00111100
.db %01000010
.db %01000010
.db %10100101
.db %10100101
.db %10000001 ;6
.db %10100101
.db %10011001
.db 0
plant_longer:
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001

.db 0
cloud_left:
.db %01101101
.db %10010010
.db %10000000
.db %10000000
.db %01000000
.db %10000000
.db %10010010
.db %01101101

.db 0

cloud_right:
.db %10110110
.db %01001001
.db %00000001
.db %00000001
.db %00000010
.db %00000001
.db %01001001
.db %10110110

.db 0

Wall:
.db %11111111
.db %11011011
.db %11011011
.db %11011011
.db %11111111
.db %11111111
.db %11111111
.db %11111111
.db 1 ; 1 = solid
Box:
.db %11111111
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %11111111

.db 1
Smile:
.db %10000001
.db %10000001
.db %10000001
.db %10000001
.db %00000000
.db %01000010
.db %01111100
.db %00000000

.db 1
four:
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000

.db 1

five:
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000
.db %00000000

.db 1

Chimwa:
	.db %11111111
	.db %10100101
	.db %10100101
	.db %10000001
	.db %10100101
	.db %10011001
    .db %10000001
	.db %11111111
	
.db 1
Creme:
.db %01111110
.db %10000001
.db %10100101
.db %10000001
.db %10011001
.db %01111110
.db %01100110
.db %11100111
		
.db 1

Coin1:
	.db %00011000	
	.db %00100100
	.db %00100100
	.db %01000010
	.db %01000010
	.db %00100100
	.db %00100100
	.db %00011000	
	.db 1
Coin2:
	.db %00011000	
	.db %00100100
	.db %00100100
	.db %01011010
	.db %01001010
	.db %00100100
	.db %00100100
	.db %00011000	
	.db 1
BlockyL:
.db $3C,$42,$A9,$A5,$8D,$86,$69,$9F
.db $3C,$42,$D5,$D3,$87,$61,$96,$F9



;.db $3C,$42,$A9,$A5,$8D,$81,$66,$99
;.db $3C,$42,$D5,$D3,$87,$81,$66,$99





     ;.db %01111110
     ;.db %10000001   ; what blocky looks like when he
     ;.db %10100001   ; is on the LEFT
     ;.db %10101001
     ;.db %10100101
     ;.db %10010011 ;0 
     ;.db %11001101
     ;.db %01111110
BlockyL2:
    ; .db %01111110
    ; .db %10000001   ; what blocky looks like when he
    ; .db %10100001   ; is on the LEFT
    ; .db %10101001
    ; .db %10100101
    ; .db %10010011 ; 1
    ; .db %11001101
    ; .db %01111110
.db $3C,$42,$95,$A5,$B1,$61,$96,$F9
.db $3C,$42,$AB,$CB,$E1,$86,$69,$9F


    
BlockyR:
.db $3C,$42,$95,$A5,$B1,$81,$66,$99 ; 2
BlockR2:
.db $3C,$42,$AB,$CB,$E1,$81,$66,$99




   ;  .db %01111110
   ;  .db %10000001   ; what blocky looks like when he
   ;  .db %10000101   ; is on the right
   ;  .db %10010101
   ;  .db %10100101
   ;  .db %11001001
   ;  .db %10110011
   ;  .db %01111110
	 
.db 1

	 
	 .db 1

Animation1:
.db %00011110
.db %00100001
.db %01010101
.db %01000010
.db %01010010
.db %10000100
.db %10000100
.db %10000100

Animation2:
.db %01111000
.db %10000100
.db %10101010
.db %01000010
.db %01001010
.db %00100001
.db %00100001
.db %00100001
Goomba_Hold:
.db %01100000
.db %10011110
.db %01111110
.db %10011001
.db %10000001
.db %10100101
.db %01000010
.db %00111100
Goomba:
.db %00111100
.db %01000010
.db %10100101
.db %10000001
.db %10011001
.db %01111110
.db %10011110
.db %01100000
Goomba_Hold2:
.db %00000110
.db %11111001
.db %01111110
.db %10011001
.db %10000001
.db %10100101
.db %01000010
.db %00111100
Goomba2:
.db %00111100
.db %01000010
.db %10100101
.db %10000001
.db %10011001
.db %01111110
.db %11111001
.db %00000110

Super_Block:
.db %01111110
.db %10000001
.db %10100101
.db %10100101
.db %10000001
.db %10111101
.db %10000001
.db %01111110
.db 1

;-----------------------------------------
;VARIABLES
Variables:
;-----------------------------------------
lives:
.db 5
delay_c:
.db 0
Up_Max:
.db 6
Up_Offset:
.db 1
Down_Max:
.db 13
Down_Offset:
.db 8
Right_Max:
.db 11
Right_Offset:
.db 8
Left_Max:
.db 0
Left_Offset:
.db 1
Block_Y:
    .db 9,1             ; blockies distance from the ground
Block_YY:
	.db 9,8
Block_X:
    .db 6,1   ; coordinates of blocky
Block_XX:      ; coorinates of blocky + 7 (end of it)
    .db 6,8
Direction:
.db 2  ;right
Dir_C:
.db 2
Saved:
.db 0
Counter:
	.db 0
TempVar:
	.db 0
Tempz:
	.db 0
Temp3:
	.db 0
AnimationC:
	.db 0
Button_C:
.db 0

velocity:
.db 0
acceleration:
.db 1
zeronum:
.db %01000000
.db %10100000
.db %10100000
.db %10100000
.db %01000000


Onenum:
.db %01000000
.db %11000000
.db %01000000
.db %01000000
.db %01000000
Twonum:
.db %11000000
.db %00100000
.db %01000000
.db %10000000
.db %11100000

Threenum:
.db %11000000
.db %00100000
.db %01000000
.db %00100000
.db %11000000

Fournum:
.db %10100000
.db %10100000
.db %11100000
.db %00100000
.db %00100000

Fivenum:
.db %11100000
.db %10000000
.db %11000000
.db %00100000
.db %11000000
	
Sixnum:
.db %01100000
.db %10000000
.db %11000000
.db %10100000
.db %01100000

Sevennum:
.db %11100000
.db %00100000
.db %01000000
.db %01000000
.db %10000000

EightNum:
.db %01000000
.db %10100000
.db %01000000
.db %10100000
.db %01000000

Ninenum:
.db %01100000
.db %10100000
.db %01100000
.db %00100000
.db %00100000
Number_Table:	
.dw zeronum
.dw onenum	
.dw twonum
.dw threenum		
.dw fournum	
.dw fivenum	
.dw Sixnum	
.dw sevennum	
.dw eightnum
.dw ninenum
.dw blank 	
	
Buffer1:
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	.db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
_enddata:
;-----------------------------------------
;-----------------------------------------
;-----------------------------------------
;-----------------------------------------
;-----------------------------------------
;-----------------------------------------
;-----------------------------------------
;-----------------------------------------

.end
